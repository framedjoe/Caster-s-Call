<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Caster's Call</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --gold: #ffd700; --gold-glow: rgba(255,215,0,0.6);
      --blue: #87ceeb; --red: #ff6b6b;
      --bg-dark: #0f0c29; --bg-mid: #302b63; --bg-light: #24243e;
      --scale: 1.5; /* Default scale */
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(-45deg, var(--bg-dark), var(--bg-mid), var(--bg-light), var(--bg-dark));
      background-size: 400% 400%; animation: gradient 15s ease infinite;
      color: white; display: flex; justify-content: center; align-items: center; padding: 0;
      overflow: hidden;
    }
    @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    h1, h2, h3, .game-title-opponent, .game-title-player, .turn-indicator, .card-name { font-family: 'Cinzel', serif; }
    /* 1.5x SCALED GAME BOARD */
    #game {
      position: relative; width: calc(960px * var(--scale)); height: calc(640px * var(--scale)); padding: calc(1px * var(--scale));
      background: rgba(15,15,25,0.7); border-radius: calc(20px * var(--scale));
      box-shadow: 0 calc(8px * var(--scale)) calc(32px * var(--scale)) rgba(0,0,0,0.37), 0 0 0 calc(1px * var(--scale)) rgba(255,215,0,0.1);
      backdrop-filter: blur(calc(12px * var(--scale))); border: calc(1px * var(--scale)) solid rgba(255,215,0,0.2);
      overflow: hidden;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transform-origin: top left;
      max-width: 100vw;
      max-height: 100vh;
    }
    .game-title-opponent, .game-title-player {
      position: absolute; top: 0; height: 100%; writing-mode: vertical-rl; text-orientation: mixed;
      font-size: calc(14px * var(--scale)); font-weight: bold; color: var(--gold); text-align: center;
      background: rgba(0,0,0,0.5); padding: calc(4px * var(--scale)) calc(2px * var(--scale)); border-radius: calc(4px * var(--scale));
      text-shadow: 0 0 calc(10px * var(--scale)) var(--gold-glow);
    }
    .game-title-opponent { left: calc(1px * var(--scale)); } .game-title-player { right: calc(1px * var(--scale)); }
    .turn-info { text-align: center; margin: calc(1px * var(--scale)) 0; flex: 0 0 auto; }
    .turn-indicator {
      display: inline-block; padding: calc(3px * var(--scale)) calc(7px * var(--scale));
      background: linear-gradient(135deg, #1a1a1a, #333);
      border: calc(1px * var(--scale)) solid var(--gold); border-radius: calc(21px * var(--scale));
      font-size: calc(11px * var(--scale)); font-weight: bold; color: var(--gold);
      text-shadow: 0 0 calc(10px * var(--scale)) var(--gold);
      box-shadow: 0 0 calc(20px * var(--scale)) rgba(255,215,0,0.4); animation: turn-glow 2s infinite alternate;
    }
    @keyframes turn-glow {
      from { box-shadow: 0 0 calc(20px * var(--scale)) rgba(255,215,0,0.4); }
      to { box-shadow: 0 0 calc(30px * var(--scale)) rgba(255,215,0,0.8), 0 0 calc(40px * var(--scale)) rgba(255,215,0,0.3); }
    }
    .turn-counter {
      font-size: calc(8px * var(--scale)); font-weight: bold; color: #ffea00; background: rgba(0,0,0,0.7);
      padding: calc(2px * var(--scale)) calc(6px * var(--scale));
      border: calc(1px * var(--scale)) solid #ffea00; border-radius: calc(21px * var(--scale));
      display: inline-block; margin-left: calc(4px * var(--scale)); animation: pulse 2s infinite;
    }
    @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }
    /* LIFE TEXT: Moved inward 90px (60px * 1.5) */
    .status {
      display: flex; justify-content: space-between; margin: calc(1px * var(--scale)) 0; font-weight: bold;
      background: rgba(0,0,0,0.5); padding: calc(3px * var(--scale)); border-radius: calc(3px * var(--scale));
      align-items: center; flex-wrap: wrap; gap: calc(2px * var(--scale)); font-size: calc(8px * var(--scale)); flex: 0 0 auto;
    }
    .status span {
      flex: 0 0 auto; min-width: calc(80px * var(--scale)); text-align: center;
    }
    .status > span:first-child { margin-left: calc(60px * var(--scale)); }
    .status > span:last-child { margin-right: calc(60px * var(--scale)); }
    .opponent-spell-zones, .opponent-monster-zones, .player-monster-zones, .player-spell-zones {
      display: flex; flex-direction: row; justify-content: center; align-items: center; gap: calc(1px * var(--scale)); flex-wrap: nowrap;
      overflow-x: auto; padding: calc(1px * var(--scale)) 0; margin: calc(1px * var(--scale)) 0; flex: 1 0 auto;
    }
    .player-monster-zone, .opponent-monster-zone, .player-spell-zone, .opponent-spell-zone {
      flex: 0 0 auto; width: calc(56px * var(--scale)); height: calc(78px * var(--scale)); min-width: calc(56px * var(--scale));
      border: calc(1px * var(--scale)) solid var(--gold); border-radius: calc(6px * var(--scale));
      display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.05); position: relative; transition: all 0.3s;
    }
    .opponent-monster-zone { background: rgba(255,0,0,0.1); }
    .zone {
      display: flex; flex-direction: row; justify-content: flex-start; align-items: center; gap: calc(1px * var(--scale)); overflow-x: auto;
      overflow-y: hidden; padding: calc(1px * var(--scale)); border: calc(1px * var(--scale)) dashed #ffd70033;
      border-radius: calc(6px * var(--scale)); background: rgba(0,0,0,0.3);
      min-height: calc(94.46px * var(--scale));
      backdrop-filter: blur(calc(4px * var(--scale))); scrollbar-width: thin; scrollbar-color: #ffd700 #333; flex: 1 0 auto;
    }
    .zone::-webkit-scrollbar { height: calc(3px * var(--scale)); }
    .zone::-webkit-scrollbar-track { background: #333; border-radius: calc(2px * var(--scale)); }
    .zone::-webkit-scrollbar-thumb { background: #ffd700; border-radius: calc(2px * var(--scale)); }
    /* CARDS: 1.5x SCALED */
    .card {
      width: calc(56px * var(--scale)); height: calc(78px * var(--scale)); border-radius: calc(6px * var(--scale));
      overflow: hidden; position: relative; cursor: pointer;
      box-shadow: 0 calc(3px * var(--scale)) calc(6px * var(--scale)) rgba(0,0,0,0.4), 0 0 0 calc(2px * var(--scale)) #000, 0 0 0 calc(4px * var(--scale)) var(--gold);
      transition: all 0.3s ease; background: #111 !important;
      transform-style: preserve-3d; perspective: 1000px;
    }
    .card.opponent-hand { cursor: default !important; pointer-events: none; }
    .card::before {
      content: ''; position: absolute; inset: 0; background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.3) 100%);
      pointer-events: none; z-index: 1;
    }
    .card:hover:not(.opponent-hand):not(.has-attacked) {
      transform: translateY(calc(-7px * var(--scale))) scale(1.08) rotateX(5deg);
      box-shadow: 0 calc(14px * var(--scale)) calc(28px * var(--scale)) rgba(0,0,0,0.6), 0 0 0 calc(2px * var(--scale)) #000, 0 0 0 calc(4px * var(--scale)) var(--gold), 0 0 calc(14px * var(--scale)) var(--gold-glow); z-index: 10;
    }
    .card-mana {
      position: absolute; top: calc(2px * var(--scale)); right: calc(2px * var(--scale));
      width: calc(12px * var(--scale)); height: calc(12px * var(--scale)); background: #000;
      border: calc(1px * var(--scale)) solid var(--gold); border-radius: 50%; color: var(--gold);
      font-weight: bold; font-size: calc(7px * var(--scale)); display: flex; align-items: center; justify-content: center; z-index: 2;
      box-shadow: 0 0 calc(6px * var(--scale)) var(--gold-glow);
    }
    .card .art {
      position: absolute; top: calc(5px * var(--scale)); left: calc(3px * var(--scale)); right: calc(3px * var(--scale));
      height: calc(40px * var(--scale)); border-radius: calc(4px * var(--scale)); overflow: hidden; background: #000;
      box-shadow: inset 0 0 calc(7px * var(--scale)) rgba(0,0,0,0.5);
    }
    .card .art img { width: 100%; height: 100%; object-fit: cover; }
    .card-name {
      position: absolute; top: calc(3px * var(--scale)); left: 0; right: 0; font-size: calc(7px * var(--scale));
      font-weight: bold; text-align: center; color: var(--gold); text-shadow: 1px 1px 2px #000; z-index: 2; padding: 0 calc(2px * var(--scale));
    }
    .card-stats {
      position: absolute; bottom: calc(2px * var(--scale)); left: calc(2px * var(--scale)); right: calc(2px * var(--scale));
      background: rgba(0,0,0,0.7); padding: calc(1px * var(--scale)) calc(2px * var(--scale)); border-radius: calc(2px * var(--scale));
      font-size: calc(5px * var(--scale)); color: #fff; text-align: center; z-index: 2; border: calc(1px * var(--scale)) solid var(--gold);
    }
    .card.opponent-hand::before { background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0.95)) !important; }
    .card.opponent-hand .card-name { color: #666; }
    /* DECK & CRYPT: 1.5x SCALED + COLORS RESTORED */
    .player-deck, .opponent-deck, .player-crypt, .opponent-crypt {
      width: calc(56px * var(--scale)); height: calc(78px * var(--scale)); border: calc(1px * var(--scale)) solid var(--gold);
      border-radius: calc(6px * var(--scale)); display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: calc(4px * var(--scale)); box-shadow: 0 calc(3px * var(--scale)) calc(8px * var(--scale)) rgba(0,0,0,0.4);
      font-size: calc(7px * var(--scale)); color: var(--gold); cursor: pointer; transition: all 0.3s;
    }
    .player-deck:hover, .opponent-deck:hover, .player-crypt:hover, .opponent-crypt:hover { transform: translateY(calc(-5px * var(--scale))); }
    .player-deck.blue-deck, .opponent-deck.blue-deck {
      background: linear-gradient(to bottom, #172554, #93c5fd);
    }
    .player-deck.red-deck, .opponent-deck.red-deck {
      background: linear-gradient(to bottom, #991b1b, #ef4444);
    }
    .player-crypt, .opponent-crypt {
      background: linear-gradient(to bottom, #444, #222);
    }
    .mana-crystals { display: inline-flex; gap: calc(1px * var(--scale)); align-items: center; }
    .mana-crystal {
      width: calc(10px * var(--scale)); height: calc(10px * var(--scale)); margin: 0 calc(1px * var(--scale));
      border-radius: 50%; background: #333; border: calc(1px * var(--scale)) solid #666; position: relative; transition: all 0.3s;
    }
    .mana-crystal.filled { background: #00ff00; border-color: #00ff00; box-shadow: 0 0 calc(10px * var(--scale)) #00ff00, inset 0 0 calc(7px * var(--scale)) rgba(255,255,255,0.5); animation: mana-pulse 2s infinite; }
    .mana-crystal.filled.blue { background: var(--blue); box-shadow: 0 0 calc(10px * var(--scale)) var(--blue), inset 0 0 calc(7px * var(--scale)) white; }
    .mana-crystal.filled.red { background: var(--red); box-shadow: 0 0 calc(10px * var(--scale)) var(--red), inset 0 0 calc(7px * var(--scale)) white; }
    @keyframes mana-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
    /* BUTTONS: COLORS RESTORED + SCALED */
    button {
      padding: calc(4px * var(--scale)) calc(8px * var(--scale)); margin: calc(2px * var(--scale)); border: none; border-radius: calc(3px * var(--scale));
      font-weight: bold; text-transform: uppercase; letter-spacing: calc(1px * var(--scale));
      cursor: pointer; transition: all 0.3s; box-shadow: 0 calc(3px * var(--scale)) calc(10px * var(--scale)) rgba(0,0,0,0.3);
      position: relative; overflow: hidden; min-height: calc(20px * var(--scale)); font-size: calc(7px * var(--scale));
    }
    button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); transition: 0.5s; }
    button:hover::before { left: 100%; }
    button:hover { transform: translateY(calc(-3px * var(--scale))); box-shadow: 0 calc(6px * var(--scale)) calc(14px * var(--scale)) rgba(0,0,0,0.4); }
    #draw-button { background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; }
    #favor-button { background: linear-gradient(135deg, #ff6b6b, #ee5a52); color: white; }
    #attack-button { background: linear-gradient(135deg, #ff9a56, #ff6b6b); color: white; }
    button#end-turn { background: linear-gradient(135deg, #333, #111); color: var(--gold); }
    #cancel-button { background: linear-gradient(135deg, #999, #666); color: white; display: none; }
    /* HAND CONTAINERS: 1.5x SCALED */
    .opponent-hand-container, .player-hand-container {
      width: calc(555.898px * var(--scale)); height: calc(94.46px * var(--scale));
      margin-left: calc(27.795px * var(--scale)); /* 5% right shift */
    }
    /* Added back from original: Playable zones, selections, animations, etc. */
    .playable-zone { border: calc(3px * var(--scale)) solid #00ff00 !important; background: rgba(0,255,0,0.15) !important; box-shadow: 0 0 calc(20px * var(--scale)) #00ff00 !important; transform: scale(1.05); }
    .card.selected { transform: translateY(calc(-15px * var(--scale))) scale(1.12) !important; box-shadow: 0 0 0 calc(4px * var(--scale)) #00ff00, 0 0 calc(30px * var(--scale)) #00ff00 !important; }
    .card.playable { box-shadow: 0 0 0 calc(4px * var(--scale)) #00ff00, 0 0 calc(25px * var(--scale)) #00ff00 !important; animation: pulse-playable 1.5s infinite; }
    @keyframes pulse-playable { 0%, 100% { box-shadow: 0 0 0 calc(4px * var(--scale)) #00ff00, 0 0 calc(20px * var(--scale)) #00ff00; } 50% { box-shadow: 0 0 0 calc(6px * var(--scale)) #00ff00, 0 0 calc(35px * var(--scale)) #00ff00; } }
    .card.no-art { background: #333 !important; }
    .card.no-art .art { display: none; }
    .attacking { animation: attackAnim 0.9s ease-out !important; }
    @keyframes attackAnim { 0% { transform: scale(1) translateY(0); } 30% { transform: scale(1.2) translateX(calc(20px * var(--scale))); } 60% { transform: scale(0.9) translateX(calc(40px * var(--scale))); } 100% { transform: scale(1) translateX(0); } }
    .attacked { animation: damageAnim 0.8s ease-out; }
    @keyframes damageAnim { 0% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.3); filter: brightness(2); } 100% { transform: scale(0); filter: brightness(0); opacity: 0; } }
    .has-attacked { filter: grayscale(50%) brightness(0.7); cursor: not-allowed; }
    .spell-glow { animation: spellGlow 0.8s ease-out; box-shadow: 0 0 calc(30px * var(--scale)) #00ffff, 0 0 calc(50px * var(--scale)) #00ffff !important; }
    @keyframes spellGlow { 0% { transform: scale(1); box-shadow: 0 0 calc(10px * var(--scale)) #00ffff; } 50% { transform: scale(1.15); box-shadow: 0 0 calc(50px * var(--scale)) #00ffff, 0 0 calc(80px * var(--scale)) #00ffff; } 100% { transform: scale(1); box-shadow: 0 0 calc(10px * var(--scale)) #00ffff; } }
    .summon-glow { animation: summonGlow 1.2s ease-out; }
    @keyframes summonGlow { 0% { transform: scale(0.8); opacity: 0; filter: brightness(2); } 50% { transform: scale(1.2); filter: brightness(1.5); } 100% { transform: scale(1); opacity: 1; filter: brightness(1); } }
    #deck-selection-popup, #game-over-popup, #player-crypt-popup, #opponent-crypt-popup {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: calc(30px * var(--scale));
      border: calc(3px * var(--scale)) solid var(--gold); border-radius: calc(16px * var(--scale)); text-align: center; color: var(--gold); font-size: calc(24px * var(--scale)); font-weight: bold; z-index: 1000;
      box-shadow: 0 0 calc(40px * var(--scale)) rgba(255,215,0,0.4);
    }
    .deck-button-blue, .deck-button-red { background: linear-gradient(to bottom, #87ceeb, #4682b4); color: white; border: calc(2px * var(--scale)) solid var(--gold); margin: calc(15px * var(--scale)); padding: calc(18px * var(--scale)) calc(36px * var(--scale)); font-size: calc(22px * var(--scale)); border-radius: calc(12px * var(--scale)); }
    .deck-button-red { background: linear-gradient(to bottom, #ff9999, #cc6666); }
    .card-tooltip {
      position: absolute; background: linear-gradient(135deg, #1a1a1a, #2d2d2d); border: calc(2px * var(--scale)) solid var(--gold); border-radius: calc(12px * var(--scale)); padding: calc(16px * var(--scale)); max-width: calc(280px * var(--scale));
      font-size: calc(14px * var(--scale)); color: var(--gold); box-shadow: 0 calc(10px * var(--scale)) calc(30px * var(--scale)) rgba(0,0,0,0.6); z-index: 1002; opacity: 0; visibility: hidden; transform: translateY(calc(10px * var(--scale)));
      transition: all 0.3s ease; pointer-events: none;
    }
    .card-tooltip.show { opacity: 1; visibility: visible; transform: translateY(0); }
    .card-tooltip h3 { margin: 0 0 calc(8px * var(--scale)); font-size: calc(18px * var(--scale)); color: #fff; }
    #notification {
      position: fixed; top: calc(20px * var(--scale)); left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: var(--gold); padding: calc(12px * var(--scale)) calc(24px * var(--scale));
      border: calc(2px * var(--scale)) solid var(--gold); border-radius: calc(50px * var(--scale)); font-size: calc(18px * var(--scale)); font-weight: bold; z-index: 1001; opacity: 0; transition: opacity .5s; pointer-events: none;
      box-shadow: 0 0 calc(20px * var(--scale)) rgba(255,215,0,0.4);
    }
    #notification.show { opacity: 1; }
    @keyframes particle { to { transform: translateY(calc(-120px * var(--scale))) scale(0); opacity: 0; } }
    @media (max-width: 768px) {
      #game { padding: calc(15px * var(--scale)); width: 100vw; height: auto; }
      .card { width: calc(90px * var(--scale)); height: calc(130px * var(--scale)); }
      .player-monster-zone, .opponent-monster-zone, .player-spell-zone, .opponent-spell-zone { width: calc(100px * var(--scale)); height: calc(140px * var(--scale)); }
      .turn-indicator { font-size: calc(20px * var(--scale)); padding: calc(10px * var(--scale)) calc(20px * var(--scale)); }
      button { padding: calc(8px * var(--scale)) calc(16px * var(--scale)); font-size: calc(10px * var(--scale)); min-width: calc(80px * var(--scale)); }
      .opponent-hand-container, .player-hand-container { width: 100%; margin-left: 0; }
      .zone { min-height: calc(100px * var(--scale)); }
    }
    .ai-attack-target { box-shadow: 0 0 0 calc(4px * var(--scale)) #ff0000, 0 0 calc(30px * var(--scale)) #ff0000 !important; animation: aiTargetPulse 1s infinite; }
    @keyframes aiTargetPulse { 0%, 100% { box-shadow: 0 0 0 calc(4px * var(--scale)) #ff0000, 0 0 calc(20px * var(--scale)) #ff0000; } 50% { box-shadow: 0 0 0 calc(6px * var(--scale)) #ff0000, 0 0 calc(40px * var(--scale)) #ff0000; } }
    #caster-coins {
      position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 5px 10px;
      border: 1px solid var(--gold); border-radius: 10px; font-size: 14px; color: var(--gold);
    }
    /* City Hub Styles */
    .hub-container {
      display: flex; flex-direction: column; align-items: center; gap: calc(16px * var(--scale));
      padding: calc(20px * var(--scale)); background: rgba(0,0,0,0.5); border-radius: calc(10px * var(--scale));
      box-shadow: 0 calc(4px * var(--scale)) calc(16px * var(--scale)) rgba(0,0,0,0.5);
      width: 80%; max-width: calc(400px * var(--scale)); z-index: 999;
    }
    .hub-title {
      font-family: 'Cinzel', serif; font-size: calc(32px * var(--scale)); color: var(--gold);
      text-shadow: 0 0 calc(10px * var(--scale)) var(--gold); margin-bottom: calc(16px * var(--scale)); text-align: center;
    }
    .hub-button {
      width: 100%; padding: calc(12px * var(--scale)); background: rgba(0,0,0,0.7);
      border: calc(1px * var(--scale)) solid var(--gold); border-radius: calc(5px * var(--scale));
      font-family: 'Roboto', sans-serif; font-size: calc(18px * var(--scale)); font-weight: bold; color: var(--gold);
      text-align: center; cursor: pointer; transition: all 0.3s;
      box-shadow: 0 calc(2px * var(--scale)) calc(8px * var(--scale)) rgba(255,215,0,0.2);
    }
    .hub-button:hover {
      background: rgba(0,0,0,0.9); box-shadow: 0 calc(4px * var(--scale)) calc(12px * var(--scale)) rgba(255,215,0,0.4);
      transform: translateY(calc(-2px * var(--scale)));
    }
    #game-board { display: none; flex-direction: column; justify-content: space-between; height: 100%; width: 100%; }
    #back-to-hub { background: linear-gradient(135deg, #999, #666); color: white; display: none; }
    @media (max-width: 768px) {
      :root { --scale: 1.0; }
      .hub-container { padding: calc(10px * var(--scale)); gap: calc(10px * var(--scale)); }
      .hub-title { font-size: calc(24px * var(--scale)); }
      .hub-button { font-size: calc(14px * var(--scale)); padding: calc(8px * var(--scale)); }
    }
    /* Binder Styles */
    .binder-card {
      width: calc(100px * var(--scale)); height: calc(140px * var(--scale)); border-radius: calc(8px * var(--scale));
      background: #111; box-shadow: 0 calc(4px * var(--scale)) calc(8px * var(--scale)) rgba(0,0,0,0.4);
      padding: calc(5px * var(--scale)); text-align: center; position: relative; color: #fff;
      transition: transform 0.3s;
    }
    .binder-card:hover { transform: scale(1.05); }
    .binder-card .card-name { font-size: calc(10px * var(--scale)); color: var(--gold); }
    .binder-card .card-stats { font-size: calc(8px * var(--scale)); }
    .binder-card .rarity { position: absolute; bottom: calc(5px * var(--scale)); left: 50%; transform: translateX(-50%); font-size: calc(8px * var(--scale)); text-transform: uppercase; }
    .rarity-common { color: gray; }
    .rarity-uncommon { color: green; }
    .rarity-rare { color: blue; }
    .rarity-super-rare { color: orange; }
    #binder-content { display: flex; flex-wrap: wrap; justify-content: center; gap: calc(10px * var(--scale)); }
    #pack-opening div { opacity: 0; transition: opacity 0.5s; font-size: calc(14px * var(--scale)); color: #fff; margin: calc(5px * var(--scale)); }
/* RARITY BORDER COLORS (Add to your <style>) */
.card.rarity-common {
  border: calc(2px * var(--scale)) solid #808080 !important; /* Gray */
  box-shadow: 0 0 calc(8px * var(--scale)) rgba(128,128,128,0.5), 0 calc(3px * var(--scale)) calc(6px * var(--scale)) rgba(0,0,0,0.4) !important;
}

.card.rarity-uncommon {
  border: calc(2px * var(--scale)) solid #00ff00 !important; /* Green */
  box-shadow: 0 0 calc(10px * var(--scale)) rgba(0,255,0,0.6), 0 calc(3px * var(--scale)) calc(6px * var(--scale)) rgba(0,0,0,0.4) !important;
}

.card.rarity-rare {
  border: calc(2px * var(--scale)) solid #4169e1 !important; /* Royal Blue */
  box-shadow: 0 0 calc(12px * var(--scale)) rgba(65,105,225,0.7), 0 calc(3px * var(--scale)) calc(6px * var(--scale)) rgba(0,0,0,0.4) !important;
}

.card.rarity-super-rare {
  border: calc(3px * var(--scale)) solid #ffa500 !important; /* Orange */
  box-shadow: 0 0 calc(16px * var(--scale)) rgba(255,165,0,0.8), 0 calc(4px * var(--scale)) calc(8px * var(--scale)) rgba(0,0,0,0.5) !important;
}

/* Hover glow enhancement for rarities */
.card.rarity-common:hover:not(.opponent-hand):not(.has-attacked) { box-shadow: 0 calc(14px * var(--scale)) calc(28px * var(--scale)) rgba(128,128,128,0.6), 0 0 0 calc(4px * var(--scale)) #808080 !important; }
.card.rarity-uncommon:hover:not(.opponent-hand):not(.has-attacked) { box-shadow: 0 calc(14px * var(--scale)) calc(28px * var(--scale)) rgba(0,255,0,0.7), 0 0 0 calc(4px * var(--scale)) #00ff00 !important; }
.card.rarity-rare:hover:not(.opponent-hand):not(.has-attacked) { box-shadow: 0 calc(14px * var(--scale)) calc(28px * var(--scale)) rgba(65,105,225,0.8), 0 0 0 calc(4px * var(--scale)) #4169e1 !important; }
.card.rarity-super-rare:hover:not(.opponent-hand):not(.has-attacked) { box-shadow: 0 calc(16px * var(--scale)) calc(32px * var(--scale)) rgba(255,165,0,0.9), 0 0 0 calc(5px * var(--scale)) #ffa500 !important; }
.card.rarity-super-rare::after {
  content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.8) 50%, transparent 70%);
  background-size: 200% 100%; animation: foil-shimmer 2s infinite;
  opacity: 0.3; pointer-events: none; z-index: 3;
}
@keyframes foil-shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
#pack-opening.pack-flip {
  position: relative; height: calc(200px * var(--scale)); background: linear-gradient(135deg, #444, #222);
  border-radius: calc(12px * var(--scale)); padding: calc(20px * var(--scale)); overflow: hidden;
}
.pack-card {
  position: absolute; width: calc(80px * var(--scale)); height: calc(112px * var(--scale)); 
  opacity: 0; transform: scale(0.5) rotateY(90deg); transition: all 0.6s cubic-bezier(0.25,0.46,0.45,0.94);
}
.pack-card.reveal { opacity: 1; transform: scale(1.1) rotateY(0deg); }
.pack-card.rare.reveal { transform: scale(1.3) rotateY(360deg) !important; animation: rare-bounce 1s; }
@keyframes rare-bounce { 0%,100%{transform:scale(1.1)} 50%{transform:scale(1.4)} }
#settings-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9); padding: calc(30px * var(--scale));
  border: calc(3px * var(--scale)) solid var(--gold); border-radius: calc(16px * var(--scale));
  text-align: center; color: var(--gold); font-size: calc(18px * var(--scale));
  z-index: 1000; box-shadow: 0 0 calc(40px * var(--scale)) rgba(255,215,0,0.4);
  width: 90%; max-width: calc(360px * var(--scale));
}
.settings-group {
  margin: calc(12px * var(--scale)) 0; display: flex; align-items: center;
  justify-content: space-between; gap: calc(10px * var(--scale));
}
.settings-group label { flex: 1; text-align: left; }
.settings-group input[type=range] { flex: 2; }
.settings-group span { flex: 0 0 auto; min-width: calc(40px * var(--scale)); }
#trunk-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.95); padding: calc(20px * var(--scale));
  border: calc(3px * var(--scale)) solid #8B4513; border-radius: calc(16px * var(--scale));
  text-align: center; color: var(--gold); font-size: calc(18px * var(--scale));
  z-index: 1001; box-shadow: 0 0 calc(50px * var(--scale)) rgba(139,69,19,0.5);
  width: 95%; max-width: calc(800px * var(--scale)); max-height: 80vh; overflow-y: auto;
}

#trunk-content {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(calc(100px * var(--scale)), 1fr));
  gap: calc(12px * var(--scale)); padding: calc(10px * var(--scale));
  justify-items: center;
}

.trunk-card {
  width: calc(90px * var(--scale)); height: calc(126px * var(--scale)); border-radius: calc(8px * var(--scale));
  background: linear-gradient(135deg, #2a1a0f, #4a3723); border: calc(2px * var(--scale)) solid #D2B48C;
  box-shadow: 0 calc(4px * var(--scale)) calc(12px * var(--scale)) rgba(0,0,0,0.6),
              inset 0 0 calc(10px * var(--scale)) rgba(255,255,255,0.1);
  display: flex; flex-direction: column; align-items: center; padding: calc(6px * var(--scale));
  transition: all 0.3s; cursor: pointer; position: relative; overflow: hidden;
}

.trunk-card:hover {
  transform: translateY(calc(-4px * var(--scale))) scale(1.05);
  box-shadow: 0 calc(8px * var(--scale)) calc(20px * var(--scale)) rgba(210,180,140,0.8);
}

.trunk-card .card-name { 
  font-size: calc(8px * var(--scale)); font-weight: bold; color: var(--gold); 
  text-shadow: 1px 1px 2px #000; margin-top: calc(2px * var(--scale));
  text-align: center; max-height: calc(20px * var(--scale)); overflow: hidden;
}

.trunk-card .rarity { 
  position: absolute; top: calc(2px * var(--scale)); right: calc(2px * var(--scale));
  font-size: calc(7px * var(--scale)); font-weight: bold; padding: calc(2px * var(--scale));
  border-radius: calc(3px * var(--scale)); background: rgba(0,0,0,0.7);
}
/* FIXED: Binder Popup with SCROLLING GRID */
#binder-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9); padding: calc(20px * var(--scale));
  border: calc(3px * var(--scale)) solid var(--gold); border-radius: calc(16px * var(--scale));
  text-align: center; color: var(--gold); font-size: calc(18px * var(--scale));
  z-index: 1000; box-shadow: 0 0 calc(40px * var(--scale)) rgba(255,215,0,0.4);
  width: 95%; max-width: calc(500px * var(--scale)); 
  max-height: 85vh; display: flex; flex-direction: column;
}

#binder-content {
  flex: 1; /* Takes available space */
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(calc(85px * var(--scale)), 1fr));
  gap: calc(8px * var(--scale));
  padding: calc(10px * var(--scale));
  overflow-y: auto; /* SCROLLABLE! */
  max-height: calc(50vh * var(--scale)); /* Fixed max height */
  justify-items: center;
  scrollbar-width: thin; scrollbar-color: var(--gold) rgba(0,0,0,0.5);
}

#binder-content::-webkit-scrollbar {
  width: calc(6px * var(--scale));
}
#binder-content::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.5); border-radius: calc(3px * var(--scale));
}
#binder-content::-webkit-scrollbar-thumb {
  background: var(--gold); border-radius: calc(3px * var(--scale));
}

/* Binder Cards - SMALLER */
.binder-card {
  width: calc(80px * var(--scale)) !important;
  height: calc(110px * var(--scale)) !important;
  border-radius: calc(6px * var(--scale));
  background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
  border: calc(1.5px * var(--scale)) solid var(--gold);
  box-shadow: 0 calc(2px * var(--scale)) calc(6px * var(--scale)) rgba(0,0,0,0.6);
  display: flex; flex-direction: column; align-items: center; justify-content: space-between;
  padding: calc(4px * var(--scale)); transition: all 0.3s; cursor: pointer; overflow: hidden;
  font-size: calc(6px * var(--scale));
}

.binder-card .card-name { font-size: calc(7px * var(--scale)); font-weight: bold; color: var(--gold); margin-bottom: calc(2px * var(--scale)); }
.binder-card .card-stats { font-size: calc(5px * var(--scale)); text-align: center; }
.binder-card .rarity { 
  position: absolute; top: calc(2px * var(--scale)); right: calc(2px * var(--scale));
  font-size: calc(6px * var(--scale)); padding: calc(1px * var(--scale)) calc(3px * var(--scale));
  border-radius: calc(3px * var(--scale)); background: rgba(0,0,0,0.8);
}

.binder-card:hover {
  transform: translateY(calc(-3px * var(--scale))) scale(1.03);
  box-shadow: 0 calc(6px * var(--scale)) calc(12px * var(--scale)) rgba(255,215,0,0.6);
}
  </style>
</head>
<body>
<div id="game">
  <div id="caster-coins">Caster Coins: 0</div>
  <div class="hub-container" id="hub-container">
    <div class="hub-title">Caster's Call City Hub</div>
    <div class="hub-button" id="arena-button" tabindex="0" role="button">Arena</div>
    <div class="hub-button" id="shop-button" tabindex="0" role="button">Shop</div>
    <div class="hub-button" id="binder-button" tabindex="0" role="button">Binder</div>
<div class="hub-button" id="settings-button" tabindex="0" role="button">Settings</div>
    <div class="hub-button" id="music-button" style="display:none;" tabindex="0" role="button">Enable Music</div>
  </div>
  <div id="game-board">
    <div class="game-title-opponent">Caster's Call</div>
    <div class="game-title-player">Caster's Call</div>
    <div class="turn-info">
      <div class="turn-indicator" id="turn-indicator">Player's Turn</div>
      <div class="turn-counter" id="turn-counter">Turn 1</div>
    </div>
    <div class="status">
      <span id="opponent-life">Opponent Life: 20</span>
      <div id="opponent-mana-crystals" class="mana-crystals"></div>
    </div>
    <div class="opponent-hand-container" style="display: flex; align-items: center; gap: calc(1px * var(--scale)); flex: 1 0 auto;">
      <div class="opponent-deck" id="opponent-deck">Deck: 30</div>
      <div class="opponent-crypt" id="opponent-crypt" onclick="openCrypt('opponent')">Crypt: 0</div>
      <div class="opponent-hand zone" style="flex: 1; overflow-x: auto; display: flex; gap: calc(1px * var(--scale));"></div>
    </div>
    <div class="opponent-spell-zones">
      <div class="opponent-spell-zone" id="opponent-spell-zone-1"></div>
      <div class="opponent-spell-zone" id="opponent-spell-zone-2"></div>
      <div class="opponent-spell-zone" id="opponent-spell-zone-3"></div>
    </div>
    <div class="opponent-monster-zones">
      <div class="opponent-monster-zone" id="opponent-monster-zone-1"></div>
      <div class="opponent-monster-zone" id="opponent-monster-zone-2"></div>
      <div class="opponent-monster-zone" id="opponent-monster-zone-3"></div>
      <div class="opponent-monster-zone" id="opponent-monster-zone-4"></div>
      <div class="opponent-monster-zone" id="opponent-monster-zone-5"></div>
    </div>
    <div class="player-monster-zones">
      <div class="player-monster-zone" id="player-monster-zone-1"></div>
      <div class="player-monster-zone" id="player-monster-zone-2"></div>
      <div class="player-monster-zone" id="player-monster-zone-3"></div>
      <div class="player-monster-zone" id="player-monster-zone-4"></div>
      <div class="player-monster-zone" id="player-monster-zone-5"></div>
    </div>
    <div class="player-spell-zones">
      <div class="player-spell-zone" id="player-spell-zone-1"></div>
      <div class="player-spell-zone" id="player-spell-zone-2"></div>
      <div class="player-spell-zone" id="player-spell-zone-3"></div>
    </div>
    <div class="player-hand-container" style="display: flex; align-items: center; gap: calc(1px * var(--scale)); flex: 1 0 auto;">
      <div class="player-hand zone" style="flex: 1; overflow-x: auto;"></div>
      <div class="player-deck" id="player-deck">Deck: 30</div>
      <div class="player-crypt" id="player-crypt" onclick="openCrypt('player')">Crypt: 0</div>
    </div>
    <div class="status">
      <span id="player-life">Player Life: 20</span>
      <div id="player-mana-crystals" class="mana-crystals"></div>
    </div>
    <div style="text-align:center; margin-top:calc(1px * var(--scale)); flex: 0 0 auto;">
      <button onclick="playerDraw()" id="draw-button">Draw</button>
      <button onclick="useFavor()" id="favor-button">Favor</button>
      <button onclick="startAttackPhase()" id="attack-button">Attack</button>
      <button onclick="endTurn()" id="end-turn">End Turn</button>
      <button onclick="attackLifePoints()" id="attack-life-button" style="display: none;">Attack Life</button>
      <button onclick="cancelSelection()" id="cancel-button" style="display: none;">Cancel</button>
      <button id="back-to-hub">Back to Hub</button>
    </div>
  </div>
  <div id="deck-selection-popup">
    <div>Choose Your Starting Deck</div>
    <button class="deck-button-blue">Blue</button>
    <button class="deck-button-red">Red</button>
  </div>
  <div id="game-over-popup">
    <div id="game-over-text"></div>
    <button onclick="resetGame(); document.getElementById('game-over-popup').style.display='none';">Retry</button>
  </div>
  <div id="player-crypt-popup">
    <div>Player's Crypt</div>
    <div id="player-crypt-content"></div>
    <button class="close-crypt" onclick="closeCryptPopup()">X</button>
  </div>
  <div id="opponent-crypt-popup">
    <div>Opponent's Crypt</div>
    <div id="opponent-crypt-content"></div>
    <button class="close-crypt" onclick="closeCryptPopup()">X</button>
  </div>
  <div id="shop-popup" style="display: none;">
    <h2 class="hub-title">Caster's Shop</h2>
    <p id="shop-coins">Caster Coins: 0</p>
    <div class="hub-button" id="buy-basic">Basic Pack (Free: 3 cards)</div>
    <div class="hub-button" id="buy-premium">Premium Pack (Free: 5 cards + 1 rare)</div>
    <div id="pack-opening" style="display: none; margin: calc(10px * var(--scale)) 0;"></div>
    <div class="hub-button" id="close-shop" style="background: linear-gradient(135deg, #666, #333);">Close</div>
  </div>
  <div id="binder-popup" style="display: none;">
  <h2 class="hub-title">Your Binder</h2>
  
  <!-- Trunk Button - FIXED POSITION -->
  <div style="margin-bottom: calc(10px * var(--scale));">
    <div class="hub-button" id="trunk-button" style="width: auto; padding: calc(8px * var(--scale)) calc(20px * var(--scale)); font-size: calc(14px * var(--scale));">
      üì¶ Trunk (All Pack Cards)
    </div>
  </div>
  
  <!-- SCROLLABLE GRID -->
  <div id="binder-content"></div>
  
  <!-- Close Button - FIXED POSITION -->
  <div style="margin-top: calc(10px * var(--scale));">
    <div class="hub-button" id="close-binder" style="background: linear-gradient(135deg, #666, #333);">Close</div>
  </div>
</div>
<!-- NEW: Trunk Popup -->
<div id="trunk-popup" style="display: none;">
  <h2 class="hub-title">üì¶ Trunk - All Pack Cards</h2>
  <p id="trunk-count" style="color: #ffd700; font-size: calc(14px * var(--scale)); margin-bottom: calc(10px * var(--scale));"></p>
  
  <div id="trunk-content"></div>
  
  <div style="display: flex; gap: calc(10px * var(--scale)); margin-top: calc(20px * var(--scale));">
    <div class="hub-button" id="close-trunk" style="background: linear-gradient(135deg, #666, #333); flex: 1;">Close</div>
    <div class="hub-button" id="clear-trunk" style="background: linear-gradient(135deg, #ff4444, #cc0000); flex: 1; color: white;">üóëÔ∏è Clear Trunk</div>
  </div>
</div>
  <div id="notification"></div>
  <div id="tooltip" class="card-tooltip"></div>
<div id="settings-popup" style="display:none;">
  <h2 class="hub-title">Settings</h2>

  <div class="settings-group">
    <label>UI Sound</label>
    <input type="range" id="ui-volume" min="0" max="100" value="50">
    <span id="ui-volume-value">50%</span>
  </div>

  <div class="settings-group">
    <label>Music</label>
    <input type="range" id="music-volume" min="0" max="100" value="30">
    <span id="music-volume-value">30%</span>
  </div>

  <!-- NEW: Reset Data button (inside the menu) -->
  <div class="settings-group" style="margin-top:calc(20px * var(--scale));">
    <button id="reset-data"
            style="background:linear-gradient(135deg,#ff4444,#cc0000);
                   color:white;padding:calc(6px * var(--scale)) calc(12px * var(--scale));
                   border:none;border-radius:calc(4px * var(--scale));
                   font-size:calc(12px * var(--scale));cursor:pointer;
                   width:100%;font-weight:bold;">
      Reset All Data
    </button>
  </div>

  <div class="hub-button" id="close-settings"
       style="background:linear-gradient(135deg,#666,#333);margin-top:calc(20px * var(--scale));">
    Close
  </div>
</div>
  <!-- MENU MUSIC -->
  <audio id="menu-music" loop>
    <source src="https://www.dropbox.com/scl/fi/qqmfdbkyot5rhj79d29zc/menu_music_casters_call.mp3.mp3?rlkey=mmt48ac4culfjh8x6n7rczyp9&st=n14w5197&dl=1" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="battle-music" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/1le2u11d6gw6ch9kgugd3/battle_casters_call.mp3.mp3?rlkey=c7bzrvimtyb50esgni0ijdhox&st=vruscezh&dl=1" type="audio/mpeg">
</audio>
  <audio id="draw-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/01m83w954zexyrrl00m85/draw-sound.mp3.mp3?rlkey=spvwo5g625qrekkgar3c64oq1&st=mwo80829&dl=1">
</audio>
  <audio id="play-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/ea7nhpqwh7aq3mzk82hmd/play-sound.mp3.mp3?rlkey=lk63vdkng4r80j2sto1cu11pv&st=cg8091xz&dl=1">
</audio>
  <audio id="attack-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/4vks8gzy7eq3gx2qy7frp/attack.mp3.mp3?rlkey=r4os85r30wfebhpwbmz6qk0r7&st=vb1q1xnw&dl=1" type="audio/mpeg">
</audio>
  <audio id="spell-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/346689__natef006__magic.mp3"></audio>
  <audio id="turn-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/1nuvuwvech7nsw3d2vysp/turn-ding.mp3.mp3?rlkey=lz7jnyr7t31trjhr0p662zt3r&st=7ma7ngug&dl=1" type="audio/mpeg">
</audio>
<audio id="ui-hover-sound" preload="auto">  <source src="https://www.dropbox.com/scl/fi/u489hmru6vfye9d4c1ufc/ui-click.mp3.mp3?rlkey=gquynaot8k7npvcql6ukybmca&st=p5f9hjca&dl=1" type="audio/mpeg">
</audio>
<audio id="ui-click-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/nd93br878m9n9sumf98dx/ui-click.mp3.mp3?rlkey=tn42j6q9sfpgccasdzqt98mbn&st=betnuuzc&dl=1">
</audio>
<audio id="card-hover-sound" preload="auto">
  <source src="https://www.dropbox.com/scl/fi/2qum84rcjlx8rcxxd5ceu/card-hover.mp3.mp3?rlkey=t1nff9ot9lnyq0oy4qf8wow39&st=fdc922x1&dl=1" type="audio/mpeg">
</audio>

</div>
<script>
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FULL GAME LOGIC ‚Äì WITH AI ATTACKS + MENU MUSIC + FIXED updateCasterCoins
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let playerLife = 20, opponentLife = 20;
let playerMana = 1, opponentMana = 1;
let turn = "player", attackPhase = false;
let hasDrawn = false, hasUsedFavor = false;
let selectedCard = null;
let playerDeck = [], opponentDeck = [], playerHand = [], opponentHand = [];
let playerPlayedCards = [], opponentPlayedCards = [], playerSpellField = [], opponentSpellField = [];
let playerCrypt = [], opponentCrypt = [];
let isOpponentTurnProcessing = false;
let playerDeckColor = null, opponentDeckColor = null;
let turnCount = 1;
let firstTurn = true;
const maxHandSize = 7;
const maxMana = 20;
const tooltip = document.getElementById('tooltip');
let selectedHandCard = null;
let casterCoins = parseInt(localStorage.getItem('casterCoins') || '0');
// MENU MUSIC
// FIXED MUSIC
const menuMusic = document.getElementById('menu-music');
const battleMusic = document.getElementById('battle-music');

function playMenuMusic() {
  menuMusic.volume = 0.3;
  menuMusic.play().catch(e => console.log('Menu music blocked:', e));
}

function playBattleMusic() {
  battleMusic.volume = 0.4;
  battleMusic.loop = true;
  battleMusic.play().catch(e => {
    console.log('Battle music blocked by browser policy:', e);
    showNotification('Click anywhere to enable battle music!'); // User hint
  });
}

function stopBattleMusic() {
  battleMusic.pause();
  battleMusic.currentTime = 0;
}

function stopMenuMusic() {
  menuMusic.pause();
  menuMusic.currentTime = 0;
}
// FIXED: Restore updateCasterCoins
function updateCasterCoins() {
  document.getElementById('caster-coins').innerText = `Caster Coins: ${casterCoins}`;
  localStorage.setItem('casterCoins', casterCoins);
}
const blueCardTemplates = [
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Oracle of Light", type: "creature", atk: 2, def: 2, mana: 1, art: "oracle-light.png" },
  { name: "Oracle of Light", type: "creature", atk: 2, def: 2, mana: 1, art: "oracle-light.png" },
  { name: "Priestess of Dawn", type: "creature", atk: 1, def: 3, mana: 1, art: "priestess-dawn.png" },
  { name: "Priestess of Dawn", type: "creature", atk: 1, def: 3, mana: 1, art: "priestess-dawn.png" },
  { name: "Sacred Maiden", type: "creature", atk: 1, def: 2, mana: 1, art: "sacred-maiden.png" },
  { name: "Sacred Maiden", type: "creature", atk: 1, def: 2, mana: 1, art: "sacred-maiden.png" },
  { name: "Great Prophet", type: "creature", atk: 5, def: 4, mana: 2, art: "great-prophet.png" },
  { name: "Great Prophet", type: "creature", atk: 5, def: 4, mana: 2, art: "great-prophet.png" },
  { name: "Prize Fighter", type: "creature", atk: 4, def: 4, mana: 2, art: "prize-fighter.png" },
  { name: "Prize Fighter", type: "creature", atk: 4, def: 4, mana: 2, art: "prize-fighter.png" },
  { name: "Royal Paladin", type: "creature", atk: 4, def: 2, mana: 2, art: "royal-paladin.png" },
  { name: "Royal Paladin", type: "creature", atk: 4, def: 2, mana: 2, art: "royal-paladin.png" },
  { name: "Templar Guardian", type: "creature", atk: 3, def: 5, mana: 2, art: "templar-guardian.png" },
  { name: "Templar Guardian", type: "creature", atk: 3, def: 5, mana: 2, art: "templar-guardian.png" },
  { name: "Holy King", type: "creature", atk: 6, def: 6, mana: 3, art: "holy-king.png" },
  { name: "Holy King", type: "creature", atk: 6, def: 6, mana: 3, art: "holy-king.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Royal Decree", type: "spell", effect: "Deal 2 damage", mana: 0, art: "royal-decree.png" },
  { name: "Royal Decree", type: "spell", effect: "Deal 2 damage", mana: 0, art: "royal-decree.png" },
  { name: "Divine Blessing", type: "spell", effect: "Restore 3 life", mana: 1, art: "divine-blessing.png" },
  { name: "Divine Blessing", type: "spell", effect: "Restore 3 life", mana: 1, art: "divine-blessing.png" },
  { name: "Light of Salvation", type: "spell", effect: "Deal 3 damage", mana: 1, art: "light-salvation.png" },
  { name: "Light of Salvation", type: "spell", effect: "Deal 3 damage", mana: 1, art: "light-salvation.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" }
];
const redCardTemplates = [
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Red Wyvern", type: "creature", atk: 1, def: 3, mana: 1, art: "red-wyvern.png" },
  { name: "Red Wyvern", type: "creature", atk: 1, def: 3, mana: 1, art: "red-wyvern.png" },
  { name: "Rogue Outlaw", type: "creature", atk: 2, def: 2, mana: 1, art: "rogue-outlaw.png" },
  { name: "Rogue Outlaw", type: "creature", atk: 2, def: 2, mana: 1, art: "rogue-outlaw.png" },
  { name: "Shadow Bandit", type: "creature", atk: 3, def: 1, mana: 1, art: "shadow-bandit.png" },
  { name: "Shadow Bandit", type: "creature", atk: 3, def: 1, mana: 1, art: "shadow-bandit.png" },
  { name: "Berserker Chieftain", type: "creature", atk: 3, def: 3, mana: 2, art: "berserker.png" },
  { name: "Berserker Chieftain", type: "creature", atk: 3, def: 3, mana: 2, art: "berserker.png" },
  { name: "Crimson Wyrm", type: "creature", atk: 4, def: 2, mana: 2, art: "crimson-wyrm.png" },
  { name: "Crimson Wyrm", type: "creature", atk: 4, def: 2, mana: 2, art: "crimson-wyrm.png" },
  { name: "Dragon Knight", type: "creature", atk: 5, def: 3, mana: 2, art: "dragon-knight.png" },
  { name: "Dragon Knight", type: "creature", atk: 5, def: 3, mana: 2, art: "dragon-knight.png" },
  { name: "Flame Marauder", type: "creature", atk: 4, def: 3, mana: 2, art: "flame-marauder.png" },
  { name: "Flame Marauder", type: "creature", atk: 4, def: 3, mana: 2, art: "flame-marauder.png" },
  { name: "Draco Emperor", type: "creature", atk: 6, def: 6, mana: 3, art: "draco-emperor.png" },
  { name: "Draco Emperor", type: "creature", atk: 6, def: 6, mana: 3, art: "draco-emperor.png" },
  { name: "Ambush Strike", type: "spell", effect: "Deal 2 damage", mana: 0, art: "ambush-strike.png" },
  { name: "Ambush Strike", type: "spell", effect: "Deal 2 damage", mana: 0, art: "ambush-strike.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Dragon's Breath", type: "spell", effect: "Deal 3 damage", mana: 1, art: "dragons-breath.png" },
  { name: "Dragon's Breath", type: "spell", effect: "Deal 3 damage", mana: 1, art: "dragons-breath.png" },
  { name: "Fiery Surge", type: "spell", effect: "Restore 3 life", mana: 1, art: "fiery-surge.png" },
  { name: "Fiery Surge", type: "spell", effect: "Restore 3 life", mana: 1, art: "fiery-surge.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" }
];
// ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ
function playSound(id) {
  const s = document.getElementById(id);
  if (s) { s.currentTime = 0; s.play().catch(() => {}); }
}
function showNotification(msg) {
  const n = document.getElementById('notification');
  n.innerText = msg; n.classList.add('show');
  setTimeout(() => n.classList.remove('show'), 3000);
}
function addParticles(el) {
  for (let i = 0; i < 10; i++) {
    const p = document.createElement('div');
    p.style.cssText = `position: absolute; width: calc(6px * var(--scale)); height: calc(6px * var(--scale)); background: #00ff00; border-radius: 50%; pointer-events: none; z-index: 5; left: ${50 + (Math.random()-0.5)*60}px; top: ${80 + (Math.random()-0.5)*40}px; animation: particle 0.8s ease-out forwards;`;
    el.appendChild(p);
    setTimeout(() => p.remove(), 800);
  }
}
function addTooltipListeners(div, card) {
  div.onmouseenter = () => {
    tooltip.innerHTML = `<h3>${card.name}</h3><div>Type: ${card.type} | Mana: ${card.mana}</div>${card.atk ? `<div>ATK: ${card.atk} | DEF: ${card.def}</div>` : ''}${card.effect ? `<div class="effect">${card.effect}</div>` : ''}`;
    tooltip.style.left = (event.pageX + 15) + 'px';
    tooltip.style.top = (event.pageY - 10) + 'px';
    tooltip.classList.add('show');
  };
  div.onmouseleave = () => tooltip.classList.remove('show');
  div.onmousemove = e => {
    tooltip.style.left = (e.pageX + 15) + 'px';
    tooltip.style.top = (e.pageY - 10) + 'px';
  };
}
function updateHandPlayability() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    const c = playerHand.find(x => x.id === div.dataset.id);
    if (c && c.mana <= playerMana) {
      div.classList.add("playable");
      div.classList.remove("unplayable");
    } else {
      div.classList.add("unplayable");
      div.classList.remove("playable");
    }
  });
}
function updateTurnDisplay() {
  document.getElementById("turn-indicator").innerText = turn === "player" ? "Player's Turn" : "Opponent's Turn";
  document.getElementById("turn-counter").innerText = `Turn ${turnCount}`;
}
function renderManaCrystals(id, mana, max = 20, color = null) {
  const c = document.getElementById(id); c.innerHTML = '';
  for (let i = 0; i < max; i++) {
    const crystal = document.createElement('div');
    crystal.className = 'mana-crystal';
    if (i < mana) { crystal.classList.add('filled'); if (color) crystal.classList.add(color); }
    c.appendChild(crystal);
  }
}
function updateManaDisplays() {
  renderManaCrystals('player-mana-crystals', playerMana, 20, playerDeckColor?.toLowerCase());
  renderManaCrystals('opponent-mana-crystals', opponentMana, 20, opponentDeckColor?.toLowerCase());
}
function showDeckSelectionPopup() {
  const popup = document.getElementById("deck-selection-popup");
  popup.style.display = "block";
  document.querySelector(".deck-button-blue").onclick = () => selectDeck('Blue');
  document.querySelector(".deck-button-red").onclick = () => selectDeck('Red');
  showNotification("Choose your deck!");
}
function selectDeck(color) {
  playerDeckColor = color;
  opponentDeckColor = color === "Blue" ? "Red" : "Blue";
  document.getElementById("player-deck").className = `player-deck ${color.toLowerCase()}-deck`;
  document.getElementById("opponent-deck").className = `opponent-deck ${opponentDeckColor.toLowerCase()}-deck`;
  document.getElementById("deck-selection-popup").style.display = "none";
  setupBoard();
  startBattle(); // ADD THIS LINE
}
function createDeck(isBlue) {
  const t = isBlue ? blueCardTemplates : redCardTemplates;
  let d = t.map((c, i) => ({ 
    ...c, 
    id: `${c.name}-${i}-${Date.now()}`, 
    hasAttacked: c.type === "creature" ? false : undefined,
    rarity: assignRarity(c.mana)  // ‚Üê ADD THIS LINE
  }));
  for (let i = d.length - 1; i > 0; i--) { 
    const j = Math.floor(Math.random() * (i + 1)); 
    [d[i], d[j]] = [d[j], d[i]]; 
  }
  return d;
}
function drawCard(deck, hand, zoneCls) {
  if (deck.length === 0 || hand.length >= maxHandSize) return;
  const card = deck.splice(Math.floor(Math.random() * deck.length), 1)[0];
  hand.push(card);
  const zone = document.querySelector(zoneCls);
  const div = document.createElement("div");

  const isOpponentHand = zoneCls.includes("opponent");
  div.className = isOpponentHand ? "card opponent-hand" : "card";
  if (!isOpponentHand && card.rarity) {
    div.classList.add(`rarity-${card.rarity}`);
  }
  div.draggable = !isOpponentHand;
  div.dataset.id = card.id;

  if (card.art) {
    const img = new Image();
    img.onload = () => { div.style.backgroundImage = `url('images/${card.art}')`; if (isOpponentHand) div.style.filter = "brightness(0.3)"; };
    img.onerror = () => div.classList.add('no-art');
    img.src = `images/${card.art}`;
  } else { div.classList.add('no-art'); }

  div.innerHTML = `
    <div class="card-mana">${card.mana}</div>
    <div class="art"><img src="images/${card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div>
    <div class="card-name">${isOpponentHand ? "??" : card.name}</div>
    ${!isOpponentHand ? `<div class="card-stats">${card.atk ? `ATK ${card.atk} | DEF ${card.def}` : card.effect || ''}</div>` : ''}
  `;

  if (!isOpponentHand) addTooltipListeners(div, card);
  zone.appendChild(div);
  playSound("draw-sound");
  if (zoneCls === ".player-hand") {
    updatePlayerDeck();
    updateHandPlayability();
    makeHandDraggable();
    attachHandClickListeners();
  } else {
    updateOpponentDeck();
  }
}
function updatePlayerDeck() { document.querySelector(".player-deck").innerText = `${playerDeckColor}: ${playerDeck.length}`; }
function updateOpponentDeck() { document.querySelector(".opponent-deck").innerText = `${opponentDeckColor}: ${opponentDeck.length}`; }
function updatePlayerCrypt() { document.querySelector(".player-crypt").innerText = `Crypt: ${playerCrypt.length}`; }
function updateOpponentCrypt() { document.querySelector(".opponent-crypt").innerText = `Crypt: ${opponentCrypt.length}`; }
function setupBoard() {
  playerDeck = createDeck(playerDeckColor === "Blue");
  opponentDeck = createDeck(opponentDeckColor === "Blue");
  playerHand = []; opponentHand = [];
  for (let i = 0; i < 4; i++) { drawCard(playerDeck, playerHand, ".player-hand"); drawCard(opponentDeck, opponentHand, ".opponent-hand"); }
  turn = Math.random() < 0.5 ? "player" : "opponent";
  turnCount = 1; updateTurnDisplay();
  document.getElementById("draw-button").disabled = turn !== "player";
  updateManaDisplays();
  if (firstTurn) {
    document.getElementById("attack-button").style.display = "none";
  }
  if (turn === "opponent") opponentTurn();
  document.getElementById("back-to-hub").style.display = "inline";
}
function updatePlayerZone() {
  for (let i = 1; i <= 5; i++) {
    const zone = document.getElementById(`player-monster-zone-${i}`);
    zone.innerHTML = "";
    const entry = playerPlayedCards.find(e => e.zone === zone.id);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = `card played ${entry.card.hasAttacked ? 'has-attacked' : ''} ${entry.card.rarity ? `rarity-${entry.card.rarity}` : ''}`;
      cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-mana">${entry.card.mana}</div><div class="art"><img src="images/${entry.card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div><div class="card-name">${entry.card.name}</div><div class="card-stats">ATK: ${entry.card.atk} DEF: ${entry.card.def}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      if (attackPhase && !entry.card.hasAttacked) {
        cardDiv.classList.add('attackable'); cardDiv.style.cursor = "pointer"; cardDiv.onclick = selectPlayerCard;
      } else { cardDiv.classList.remove('attackable'); cardDiv.style.cursor = "default"; cardDiv.onclick = null; }
      zone.appendChild(cardDiv);
    }
  }
}
function updateOpponentZone() {
  for (let i = 1; i <= 5; i++) {
    const zone = document.getElementById(`opponent-monster-zone-${i}`);
    zone.innerHTML = "";
    const entry = opponentPlayedCards.find(e => e.zone === `opponent-monster-zone-${i}`);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = `card opponent played ${entry.card.hasAttacked ? 'has-attacked' : ''} ${entry.card.rarity ? `rarity-${entry.card.rarity}` : ''}`;
      cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-mana">${entry.card.mana}</div><div class="art"><img src="images/${entry.card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div><div class="card-name">${entry.card.name}</div><div class="card-stats">ATK: ${entry.card.atk} DEF: ${entry.card.def}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      if (attackPhase && selectedCard && !selectedCard.hasAttacked) {
        cardDiv.classList.add('attack-target'); cardDiv.style.cursor = "crosshair"; cardDiv.onclick = handlePlayerAttack;
      } else { cardDiv.classList.remove('attack-target'); cardDiv.style.cursor = "default"; cardDiv.onclick = null; }
      zone.appendChild(cardDiv);
    }
  }
}
function updatePlayerSpellZone() {
  for (let i = 1; i <= 3; i++) {
    const zone = document.getElementById(`player-spell-zone-${i}`);
    zone.innerHTML = "";
    const entry = playerSpellField.find(e => e.zone === zone.id);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = "card spell"; cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-name">${entry.card.name}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      zone.appendChild(cardDiv);
    }
  }
}
function updateOpponentSpellZone() {
  for (let i = 1; i <= 3; i++) {
    const zone = document.getElementById(`opponent-spell-zone-${i}`);
    zone.innerHTML = "";
    const entry = opponentSpellField.find(e => e.zone === `opponent-spell-zone-${i}`);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = "card opponent spell"; cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-name">${entry.card.name}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      zone.appendChild(cardDiv);
    }
  }
}
function trySelectCardFromHand(div) {
  if (turn !== "player" || attackPhase) return;
  cancelSelection();
  const id = div.dataset.id;
  const card = playerHand.find(c => c.id === id);
  if (!card || card.mana > playerMana) { showNotification("Not enough mana!"); return; }
  selectedHandCard = div; div.classList.add('selected');
  document.getElementById("cancel-button").style.display = "inline";
  showNotification(`Selected: ${card.name} - Click a zone to play or Cancel`);
  highlightAvailableZones(card.type);
}
function highlightAvailableZones(cardType) {
  document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; });
  if (cardType === "creature") {
    for (let i = 1; i <= 5; i++) {
      const zone = document.getElementById(`player-monster-zone-${i}`);
      if (!playerPlayedCards.some(p => p.zone === zone.id)) {
        zone.classList.add('playable-zone');
        zone.onclick = () => playCardToZone(selectedHandCard, zone.id);
      }
    }
  } else if (cardType === "spell") {
    for (let i = 1; i <= 3; i++) {
      const zone = document.getElementById(`player-spell-zone-${i}`);
      if (!playerSpellField.some(p => p.zone === zone.id)) {
        zone.classList.add('playable-zone');
        zone.onclick = () => playCardToZone(selectedHandCard, zone.id);
      }
    }
  }
}
function cancelSelection() {
  if (selectedHandCard) {
    selectedHandCard.classList.remove('selected');
    selectedHandCard = null;
  }
  document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => {
    z.classList.remove('playable-zone');
    z.onclick = null;
  });
  document.getElementById("cancel-button").style.display = "none";
  showNotification("Selection canceled");
}
function playCardToZone(cardDiv, targetZoneId) {
  if (!selectedHandCard) return;
  const id = cardDiv.dataset.id;
  const card = playerHand.find(c => c.id === id);
  if (!card) return;
  document.getElementById("cancel-button").style.display = "none";
  document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; });
  selectedHandCard.classList.remove('selected'); selectedHandCard = null;
  if (card.type === "creature") {
    if (playerMana < card.mana || playerPlayedCards.some(p => p.zone === targetZoneId)) return;
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id); cardDiv.remove();
    card.hasAttacked = false; playerPlayedCards.push({ card, zone: targetZoneId });
    updatePlayerZone(); updateOpponentZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const newC = document.getElementById(targetZoneId).querySelector('.card');
    if (newC) { addParticles(newC); playSound('play-sound'); }
    checkGameOver();
  } else if (card.type === "spell") {
    if (playerMana < card.mana || playerSpellField.some(p => p.zone === targetZoneId)) return;
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id); cardDiv.remove();
    playerSpellField.push({ card, zone: targetZoneId });
    updatePlayerSpellZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const spellC = document.querySelector(`#${targetZoneId} .card`);
    if (spellC) {
      spellC.classList.add('spell-glow'); playSound('spell-sound');
      setTimeout(() => {
        playerSpellField = playerSpellField.filter(e => e.card.id !== card.id);
        playerCrypt.push(card); updatePlayerCrypt(); updatePlayerSpellZone(); updatePlayerZone(); updateOpponentZone();
        spellC.classList.remove('spell-glow');
        if (card.effect === "Restore 3 life") { playerLife += 3; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; opponentLife -= dmg; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let j = 0; j < 2 && playerHand.length < maxHandSize && playerDeck.length > 0; j++) drawCard(playerDeck, playerHand, ".player-hand"); }
        else if (card.effect === "Revive a monster from the Crypt") {
          const rev = playerCrypt.find(c => c.type === "creature");
          if (rev) {
            let empty = null;
            for (let k = 1; k <= 5; k++) if (!playerPlayedCards.find(p => p.zone === `player-monster-zone-${k}`)) { empty = `player-monster-zone-${k}`; break; }
            if (empty) { playerCrypt = playerCrypt.filter(c => c.id !== rev.id); rev.hasAttacked = false; playerPlayedCards.push({ card: rev, zone: empty }); updatePlayerCrypt(); updatePlayerZone(); updateOpponentZone(); }
          }
        }
        checkGameOver();
      }, 800);
    }
  }
}
function attachHandClickListeners() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    if (!div.dataset.clickListener) {
      div.dataset.clickListener = "true"; div.style.cursor = "pointer"; div.title = "Click to select";
      div.addEventListener("click", () => trySelectCardFromHand(div));
    }
  });
}
function makeHandDraggable() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    if (!div.dataset.dragListener) {
      div.draggable = true; div.dataset.dragListener = "true";
      div.addEventListener("dragstart", e => { if (turn === "player" && !attackPhase) e.dataTransfer.setData("text", div.dataset.id); });
    }
  });
  attachHandClickListeners();
}
for (let i = 1; i <= 5; i++) {
  const zone = document.getElementById(`player-monster-zone-${i}`);
  zone.addEventListener("dragover", e => e.preventDefault());
  zone.addEventListener("drop", e => {
    e.preventDefault(); if (turn !== "player" || attackPhase) return;
    const id = e.dataTransfer.getData("text");
    const card = playerHand.find(c => c.id === id);
    if (!card || card.type !== "creature" || playerMana < card.mana || playerPlayedCards.some(p => p.zone === zone.id)) return;
    if (selectedHandCard) { selectedHandCard.classList.remove('selected'); selectedHandCard = null; document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; }); }
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id);
    document.querySelector(`.player-hand .card[data-id="${id}"]`)?.remove();
    card.hasAttacked = false; playerPlayedCards.push({ card, zone: zone.id });
    updatePlayerZone(); updateOpponentZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const newC = zone.querySelector(".card"); if (newC) { addParticles(newC); playSound('play-sound'); }
    document.getElementById("cancel-button").style.display = "none";
    checkGameOver();
  });
}
for (let i = 1; i <= 3; i++) {
  const zone = document.getElementById(`player-spell-zone-${i}`);
  zone.addEventListener("dragover", e => e.preventDefault());
  zone.addEventListener("drop", e => {
    e.preventDefault(); if (turn !== "player" || attackPhase) return;
    const id = e.dataTransfer.getData("text");
    const card = playerHand.find(c => c.id === id);
    if (!card || card.type !== "spell" || playerMana < card.mana || playerSpellField.some(p => p.zone === zone.id)) return;
    if (selectedHandCard) { selectedHandCard.classList.remove('selected'); selectedHandCard = null; document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; }); }
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id);
    document.querySelector(`.player-hand .card[data-id="${id}"]`)?.remove();
    playerSpellField.push({ card, zone: zone.id });
    updatePlayerSpellZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const spellC = zone.querySelector('.card');
    if (spellC) {
      spellC.classList.add('spell-glow'); playSound('spell-sound');
      setTimeout(() => {
        playerSpellField = playerSpellField.filter(e => e.card.id !== card.id);
        playerCrypt.push(card); updatePlayerCrypt(); updatePlayerSpellZone(); updatePlayerZone(); updateOpponentZone();
        spellC.classList.remove('spell-glow');
        if (card.effect === "Restore 3 life") { playerLife += 3; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; opponentLife -= dmg; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let j = 0; j < 2 && playerHand.length < maxHandSize && playerDeck.length > 0; j++) drawCard(playerDeck, playerHand, ".player-hand"); }
        else if (card.effect === "Revive a monster from the Crypt") {
          const rev = playerCrypt.find(c => c.type === "creature");
          if (rev) {
            let empty = null;
            for (let k = 1; k <= 5; k++) if (!playerPlayedCards.find(p => p.zone === `player-monster-zone-${k}`)) { empty = `player-monster-zone-${k}`; break; }
            if (empty) { playerCrypt = playerCrypt.filter(c => c.id !== rev.id); rev.hasAttacked = false; playerPlayedCards.push({ card: rev, zone: empty }); updatePlayerCrypt(); updatePlayerZone(); updateOpponentZone(); }
          }
        }
        checkGameOver();
      }, 800);
    }
    document.getElementById("cancel-button").style.display = "none";
  });
}
function useFavor() {
  if (turn !== "player" || hasUsedFavor || attackPhase) return;
  playerMana += 1; playerLife -= 1; updateManaDisplays();
  document.getElementById("player-life").innerText = `Player Life: ${playerLife}`;
  hasUsedFavor = true; document.getElementById("favor-button").disabled = true; document.getElementById("favor-button").innerText = "Favor (Used)";
  playSound("spell-sound"); showNotification("You sacrificed life for mana!"); checkGameOver();
}
function startAttackPhase() {
  if (turn !== "player" || attackPhase) return;
  attackPhase = true;
  document.getElementById("attack-button").disabled = true;
  const canAttack = playerPlayedCards.some(e => !e.card.hasAttacked);
  document.getElementById("attack-life-button").style.display = (canAttack && opponentPlayedCards.length === 0) ? "inline" : "none";
  updatePlayerZone(); updateOpponentZone();
  showNotification("Attack phase! Click your monster, then opponent's monster or life.");
}
function selectPlayerCard(e) {
  const cardId = e.target.dataset.id;
  const entry = playerPlayedCards.find(e => e.card.id === cardId);
  if (!entry || entry.card.hasAttacked) return;
  if (selectedCard) document.querySelector(`.card[data-id="${selectedCard.id}"]`)?.classList.remove("selected");
  selectedCard = entry.card;
  e.target.classList.add("selected");
  updateOpponentZone();
}
function handlePlayerAttack(e) {
  if (!selectedCard || selectedCard.hasAttacked) return;
  const targetId = e.target.dataset.id;
  const target = opponentPlayedCards.find(e => e.card.id === targetId);
  if (!target) return;
  const attacker = document.querySelector(`.card[data-id="${selectedCard.id}"]`);
  attacker.classList.add('attacking'); playSound("attack-sound");
  setTimeout(() => {
    attacker.classList.remove('attacking'); attacker.classList.add('has-attacked');
  }, 900);
  if (selectedCard.atk >= target.card.def) {
    opponentPlayedCards = opponentPlayedCards.filter(e => e.card.id !== targetId);
    opponentCrypt.push(target.card); updateOpponentCrypt();
  }
  selectedCard.hasAttacked = true; selectedCard = null;
  document.getElementById("attack-life-button").style.display = opponentPlayedCards.length === 0 ? "inline" : "none";
  updatePlayerZone(); updateOpponentZone(); checkGameOver();
}
function attackLifePoints() {
  if (!selectedCard || selectedCard.hasAttacked) return;
  const damage = selectedCard.atk;
  opponentLife -= damage; document.getElementById("opponent-life").innerText = `Opponent Life: ${opponentLife}`;
  opponentMana += damage; opponentMana = Math.min(opponentMana, maxMana); updateManaDisplays();
  selectedCard.hasAttacked = true; document.querySelector(`.card[data-id="${selectedCard.id}"]`).classList.add('has-attacked');
  selectedCard = null; updatePlayerZone(); checkGameOver();
}
function endTurn() {
  if (attackPhase) {
    attackPhase = false; document.getElementById("attack-button").disabled = false;
    document.getElementById("attack-life-button").style.display = "none"; selectedCard = null;
  }
  playerPlayedCards.forEach(e => { if (e.card.type === "creature") e.card.hasAttacked = false; });
  opponentPlayedCards.forEach(e => { if (e.card.type === "creature") e.card.hasAttacked = false; });
  turn = turn === "player" ? "opponent" : "player"; turnCount++;
  updateManaDisplays(); playSound("turn-sound");
  firstTurn = false;
  document.getElementById("attack-button").style.display = "inline";
  if (turn === "player") {
    hasDrawn = false; hasUsedFavor = false;
    document.getElementById("draw-button").disabled = false;
    document.getElementById("draw-button").innerText = "Draw";
    document.getElementById("favor-button").disabled = false; document.getElementById("favor-button").innerText = "Favor";
    document.getElementById("attack-button").disabled = false;
    updateTurnDisplay(); updatePlayerZone(); updateOpponentZone(); updatePlayerSpellZone(); updateOpponentSpellZone();
    updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
  } else opponentTurn();
}
function playerDraw() {
  if (turn !== "player" || hasDrawn || attackPhase || playerHand.length >= maxHandSize) return;
  drawCard(playerDeck, playerHand, ".player-hand"); hasDrawn = true; document.getElementById("draw-button").disabled = true; document.getElementById("draw-button").innerText = "Draw (Used)";
}
function checkGameOver() {
  if (playerLife <= 0) {
    document.getElementById("game-over-text").innerText = "You Lose!";
    document.getElementById("game-over-popup").style.display = "block";
  } else if (opponentLife <= 0) {
    casterCoins += 10;
    updateCasterCoins();
    document.getElementById("game-over-text").innerText = "You Win! (+10 Caster Coins)";
    document.getElementById("game-over-popup").style.display = "block";
  }
}
function resetGame() {
  document.getElementById('game-over-popup').style.display = 'none';
  backToHub();
}
function closeCryptPopup() {
  document.getElementById('player-crypt-popup').style.display = 'none';
  document.getElementById('opponent-crypt-popup').style.display = 'none';
}
function openCrypt(side) {
  const popup = document.getElementById(`${side}-crypt-popup`);
  const content = document.getElementById(`${side}-crypt-content`);
  const crypt = side === 'player' ? playerCrypt : opponentCrypt;
  content.innerHTML = '';
  crypt.forEach(card => {
    const div = document.createElement('div');
    div.className = 'card';
    div.style.margin = 'calc(5px * var(--scale))'; div.style.display = 'inline-block';
    div.style.width = 'calc(56px * var(--scale))'; div.style.height = 'calc(78px * var(--scale))';
    if (card.art) {
      const img = new Image();
      img.src = `images/${card.art}`;
      img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'cover';
      img.onerror = () => div.classList.add('no-art');
      div.appendChild(img);
    } else div.classList.add('no-art');
    div.innerHTML += `<div class="card-name">${card.name}</div>`;
    addTooltipListeners(div, card);
    content.appendChild(div);
  });
  popup.style.display = 'block';
}
// ‚îÄ‚îÄ AI TURN WITH ATTACKS ‚îÄ‚îÄ
function opponentTurn() {
  if (isOpponentTurnProcessing) return; isOpponentTurnProcessing = true;
  drawCard(opponentDeck, opponentHand, ".opponent-hand");
  let played = 0; const maxPlays = Math.min(3, opponentMana);
  const tryPlay = () => {
    if (played >= maxPlays || opponentMana <= 0) { setTimeout(opponentAttackPhase, 800); return; }
    const playable = opponentHand.filter(c => c.mana <= opponentMana);
    if (playable.length === 0) { setTimeout(opponentAttackPhase, 800); return; }
    const card = playable.sort((a,b) => b.mana - a.mana)[0];
    const idx = opponentHand.indexOf(card);
    opponentPlayCard(card, idx); played++;
    setTimeout(tryPlay, 1000);
  };
  setTimeout(tryPlay, 800);
}
function opponentAttackPhase() {
  const attackers = opponentPlayedCards.filter(e => !e.card.hasAttacked).sort((a,b) => b.card.atk - a.card.atk);
  if (attackers.length === 0 || firstTurn) { setTimeout(() => { isOpponentTurnProcessing = false; endTurn(); }, 800); return; }
  const attackNext = () => {
    if (attackers.length === 0) { setTimeout(() => { isOpponentTurnProcessing = false; endTurn(); }, 1000); return; }
    const attacker = attackers.shift();
    const attackerEl = document.querySelector(`#${attacker.zone} .card`);
    if (!attackerEl) { attackNext(); return; }
    let target = playerPlayedCards
      .filter(p => p.card.def <= attacker.card.atk)
      .sort((a,b) => b.card.atk - a.card.atk)[0];
    let targetEl = null;
    if (target) { targetEl = document.querySelector(`#${target.zone} .card`); if (targetEl) targetEl.classList.add('ai-attack-target'); }
    attackerEl.classList.add('attacking'); playSound("attack-sound");
    setTimeout(() => {
      attackerEl.classList.remove('attacking'); attackerEl.classList.add('has-attacked'); attacker.card.hasAttacked = true;
      if (target && targetEl) {
        targetEl.classList.add('attacked');
        playerPlayedCards = playerPlayedCards.filter(p => p.card.id !== target.card.id);
        playerCrypt.push(target.card); updatePlayerCrypt();
        setTimeout(() => targetEl.remove(), 800);
      } else if (playerPlayedCards.length === 0) {
        playerLife -= attacker.card.atk; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`;
        playerMana += attacker.card.atk; playerMana = Math.min(playerMana, maxMana); updateManaDisplays();
        showNotification(`Opponent attacks for ${attacker.card.atk}!`);
      }
      updatePlayerZone(); updateOpponentZone(); checkGameOver();
      setTimeout(attackNext, 1200);
    }, 900);
  };
  setTimeout(attackNext, 600);
}
function opponentPlayCard(card, idx) {
  opponentMana -= card.mana; updateManaDisplays();
  opponentHand.splice(idx, 1); document.querySelector(`.opponent-hand .card[data-id="${card.id}"]`)?.remove();
  if (card.type === "spell") {
    const zones = [];
    for (let i = 1; i <= 3; i++) if (!opponentSpellField.find(e => e.zone === `opponent-spell-zone-${i}`)) zones.push(i);
    if (zones.length > 0) {
      const z = zones[Math.floor(Math.random() * zones.length)];
      opponentSpellField.push({ card, zone: `opponent-spell-zone-${z}` });
      updateOpponentSpellZone();
      const el = document.querySelector(`#opponent-spell-zone-${z} .card`);
      if (el) { el.classList.add('spell-glow'); playSound('spell-sound'); }
      setTimeout(() => {
        opponentSpellField = opponentSpellField.filter(e => e.card.id !== card.id);
        opponentCrypt.push(card); updateOpponentCrypt(); updateOpponentSpellZone();
        if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; playerLife -= dmg; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect === "Restore 3 life") { opponentLife += 3; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let i = 0; i < 2 && opponentHand.length < maxHandSize; i++) drawCard(opponentDeck, opponentHand, ".opponent-hand"); }
        checkGameOver();
      }, 800);
    }
  } else {
    const zones = [];
    for (let i = 1; i <= 5; i++) if (!opponentPlayedCards.find(e => e.zone === `opponent-monster-zone-${i}`)) zones.push(i);
    if (zones.length > 0) {
      const z = zones[Math.floor(Math.random() * zones.length)];
      card.hasAttacked = false; opponentPlayedCards.push({ card, zone: `opponent-monster-zone-${z}` });
      updateOpponentZone();
      const el = document.querySelector(`#opponent-monster-zone-${z} .card`);
      if (el) { el.classList.add('summon-glow'); addParticles(el); playSound('play-sound'); setTimeout(() => el.classList.remove('summon-glow'), 1200); }
    }
  }
  checkGameOver();
}
// Dynamic scaling for responsiveness
function updateScale() {
  const baseWidth = 960;
  const baseHeight = 640;
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  let scale = Math.min(viewportWidth / baseWidth, viewportHeight / baseHeight);
  scale = Math.max(scale, 0.8);
  if (viewportWidth < 768 && viewportHeight > viewportWidth) {
    scale *= 0.9;
  }
  document.documentElement.style.setProperty('--scale', scale);
  document.body.style.display = 'none';
  setTimeout(() => { document.body.style.display = 'flex'; }, 0);
}
// City Hub Functions
function goToArena() {
  stopMenuMusic();
  playBattleMusic();  // ‚Üê ADDED: Play battle music
  document.getElementById('hub-container').style.display = 'none';
  document.getElementById('game-board').style.display = 'flex';
  document.getElementById('game').style.justifyContent = 'space-between';
  showDeckSelectionPopup();
}
function backToHub() {
  stopBattleMusic();
  document.getElementById('hub-container').style.display = 'flex';
  document.getElementById('game-board').style.display = 'none';
  document.getElementById('game').style.justifyContent = 'center';
  playerLife = 20; opponentLife = 20;
  playerMana = 1; opponentMana = 1;
  playerDeck = []; opponentDeck = [];
  playerHand = []; opponentHand = [];
  playerPlayedCards = []; opponentPlayedCards = [];
  playerSpellField = []; opponentSpellField = [];
  playerCrypt = []; opponentCrypt = [];
  turn = "player"; attackPhase = false;
  hasDrawn = false; hasUsedFavor = false;
  selectedCard = null;
  selectedHandCard = null;
  turnCount = 1;
  firstTurn = true;
  playerDeckColor = null; opponentDeckColor = null;
  isOpponentTurnProcessing = false;
  document.querySelector('.player-hand').innerHTML = '';
  document.querySelector('.opponent-hand').innerHTML = '';
  document.getElementById('player-mana-crystals').innerHTML = '';
  document.getElementById('opponent-mana-crystals').innerHTML = '';
  document.getElementById('player-life').innerText = 'Player Life: 20';
  document.getElementById('opponent-life').innerText = 'Opponent Life: 20';
  document.getElementById('player-deck').innerText = 'Deck: 30';
  document.getElementById('opponent-deck').innerText = 'Deck: 30';
  document.getElementById('player-crypt').innerText = 'Crypt: 0';
  document.getElementById('opponent-crypt').innerText = 'Crypt: 0';
  document.getElementById('draw-button').innerText = 'Draw';
  document.getElementById('favor-button').innerText = 'Favor';
  document.getElementById('draw-button').disabled = false;
  document.getElementById('favor-button').disabled = false;
  document.getElementById('attack-button').disabled = false;
  document.getElementById('attack-life-button').style.display = 'none';
  document.getElementById('cancel-button').style.display = 'none';
  document.getElementById('back-to-hub').style.display = 'none';
  for (let i = 1; i <= 5; i++) {
    document.getElementById(`player-monster-zone-${i}`).innerHTML = '';
    document.getElementById(`opponent-monster-zone-${i}`).innerHTML = '';
  }
  for (let i = 1; i <= 3; i++) {
    document.getElementById(`player-spell-zone-${i}`).innerHTML = '';
    document.getElementById(`opponent-spell-zone-${i}`).innerHTML = '';
  }
  playMenuMusic();
}
function openShop() {
  document.getElementById('hub-container').style.display = 'none';
  document.getElementById('shop-popup').style.display = 'block';
  document.getElementById('shop-coins').innerText = `Caster Coins: ${casterCoins}`;
  document.getElementById('pack-opening').style.display = 'none';
}
function closeShop() {
  document.getElementById('shop-popup').style.display = 'none';
  document.getElementById('hub-container').style.display = 'flex';
}
function assignRarity(mana) {
  if (mana === 0) return 'common';
  if (mana === 1) return 'uncommon';
  if (mana === 2) return 'rare';
  if (mana >= 3) return 'super-rare';
  return 'common';
}
function buyPack(type) {
  const cost = 0;
  const numCards = type === 'basic' ? 3 : 5;
  const templates = Math.random() < 0.5 ? blueCardTemplates : redCardTemplates;
  const newCards = [];
  for (let i = 0; i < numCards; i++) {
    const randIdx = Math.floor(Math.random() * templates.length);
    const card = { ...templates[randIdx], id: `${templates[randIdx].name}-${Date.now()}` };
    card.rarity = assignRarity(card.mana);
    newCards.push(card);
  }
  if (type === 'premium') {
    const rareTemplates = templates.filter(c => c.mana >= 2);
    const rare = { ...rareTemplates[Math.floor(Math.random() * rareTemplates.length)], id: `rare-${Date.now()}` };
    rare.rarity = assignRarity(rare.mana);
    newCards.push(rare);
  }
  let collection = JSON.parse(localStorage.getItem('playerCollection') || '[]');
  collection = [...collection, ...newCards];
  localStorage.setItem('playerCollection', JSON.stringify(collection));
  
  // ‚úÖ ALWAYS SAVE TO TRUNK (new + duplicates)
  let trunkCards = JSON.parse(localStorage.getItem('trunkCards') || '[]');
  trunkCards.push(...newCards);
  localStorage.setItem('trunkCards', JSON.stringify(trunkCards));
  const openingDiv = document.getElementById('pack-opening');
  openingDiv.innerHTML = '<p style="color: #fff; font-size: calc(12px * var(--scale));">Opening pack...</p>';
  openingDiv.style.display = 'block';
  openingDiv.classList.add('pack-flip'); // ‚Üê THIS LINE WAS MISSING!

  newCards.forEach((card, idx) => {
    setTimeout(() => {
      const cardEl = document.createElement('div');
      cardEl.className = `pack-card rarity-${card.rarity}`;
      cardEl.innerHTML = `<div class="card-name">${card.name}</div><div>Rarity: ${card.rarity.toUpperCase()}</div>`;
      cardEl.style.animationDelay = `${idx * 0.5}s`;
      openingDiv.appendChild(cardEl);
      setTimeout(() => cardEl.classList.add('reveal'), 100); // Staggered flip
    }, idx * 600);
  });
  showNotification(`Bought ${type} pack! Added ${newCards.length} cards.`);
}
function openBinder() {
  document.getElementById('hub-container').style.display = 'none';
  document.getElementById('binder-popup').style.display = 'block';
  loadCollection();
}
function closeBinder() {
  document.getElementById('binder-popup').style.display = 'none';
  document.getElementById('hub-container').style.display = 'flex';
}
/* ---------- BINDER & TRUNK SYSTEM ---------- */
function loadCollection() {
  const content = document.getElementById('binder-content');
  content.innerHTML = '';
  const collection = JSON.parse(localStorage.getItem('playerCollection') || '[]');
  
  // Migrate old cards to trunk ONCE
  if (!localStorage.getItem('trunkCards') && collection.length > 0) {
    localStorage.setItem('trunkCards', JSON.stringify(collection));
    showNotification('üì¶ Migrated old cards to Trunk!');
  }
  
  // UNIQUE cards only (removes duplicates by ID)
  const uniqueCards = [];
  const seen = new Set();
  
  collection.forEach(card => {
    if (!seen.has(card.id)) {
      seen.add(card.id);
      uniqueCards.push(card);
    }
  });
  
  if (uniqueCards.length === 0) {
    content.innerHTML = '<p style="color: #fff; font-size: calc(14px * var(--scale)); padding: calc(20px * var(--scale));">No cards in your binder yet!<br><small>Open packs in the Shop!</small></p>';
    return;
  }
  
  uniqueCards.forEach(card => {
    const cardEl = document.createElement('div');
    cardEl.className = `binder-card rarity-${card.rarity || 'common'}`;
    cardEl.innerHTML = `
      <div class="card-name">${card.name}</div>
      <div class="card-stats">${card.atk ? `ATK ${card.atk}<br>DEF ${card.def}` : (card.effect || '').split(' ').slice(0,8).join(' ')}</div>
      <div class="rarity rarity-${card.rarity || 'common'}">${(card.rarity || 'C')[0]}</div>
    `;
    if (card.art) {
      cardEl.style.backgroundImage = `url('images/${card.art}')`;
      cardEl.style.backgroundSize = 'cover';
      cardEl.style.backgroundPosition = 'center';
    }
    content.appendChild(cardEl);
  });
}

function loadTrunk() {
  const content = document.getElementById('trunk-content');
  const countEl = document.getElementById('trunk-count');
  const allPackCards = JSON.parse(localStorage.getItem('trunkCards') || '[]');
  
  countEl.innerText = `Total Pack Cards: ${allPackCards.length}`;
  content.innerHTML = '';
  
  if (allPackCards.length === 0) {
    content.innerHTML = '<p style="color: #D2B48C; font-size: calc(16px * var(--scale)); grid-column: 1/-1;">Trunk is empty!</p>';
    return;
  }
  
  // Show ALL cards (with duplicates)
  allPackCards.slice(-100).reverse().forEach(card => {  // Last 100 for performance
    const cardEl = document.createElement('div');
    cardEl.className = `trunk-card rarity-${card.rarity || 'common'}`;
    cardEl.innerHTML = `
      <div class="rarity">${(card.rarity || 'Common')[0].toUpperCase()}</div>
      <div class="card-name">${card.name}</div>
    `;
    if (card.art) {
      const img = document.createElement('img');
      img.src = `images/${card.art}`;
      img.style.cssText = `width: 100%; height: calc(70% * var(--scale)); object-fit: cover; border-radius: calc(4px * var(--scale)); margin-bottom: calc(2px * var(--scale));`;
      img.onerror = () => img.style.background = '#333';
      cardEl.appendChild(img);
    }
    content.appendChild(cardEl);
  });
  
  if (allPackCards.length > 100) {
    const moreEl = document.createElement('div');
    moreEl.innerHTML = `<p style="color: #D2B48C; font-size: calc(14px * var(--scale)); grid-column: 1/-1;">... and ${allPackCards.length - 100} more cards</p>`;
    content.appendChild(moreEl);
  }
}

function clearTrunk() {
  if (confirm('Clear ALL pack cards from trunk? This cannot be undone.')) {
    localStorage.removeItem('trunkCards');
    loadTrunk();
    showNotification('üóëÔ∏è Trunk cleared!');
  }
}
document.getElementById('trunk-button').addEventListener('click', () => {
  document.getElementById('binder-popup').style.display = 'none';
  document.getElementById('trunk-popup').style.display = 'block';
  loadTrunk();
});

document.getElementById('close-trunk').addEventListener('click', () => {
  document.getElementById('trunk-popup').style.display = 'none';
  document.getElementById('binder-popup').style.display = 'block';  // ‚Üê ADD THIS LINE
  loadCollection();  // Refresh binder
});

document.getElementById('clear-trunk').addEventListener('click', clearTrunk);
// Attach listeners
window.addEventListener('resize', updateScale);
window.addEventListener('orientationchange', updateScale);
// START
window.addEventListener('load', () => {
  updateCasterCoins();
  updateScale();
  document.getElementById('arena-button').addEventListener('click', goToArena);
  document.getElementById('shop-button').addEventListener('click', openShop);
  document.getElementById('binder-button').addEventListener('click', openBinder);
  document.getElementById('back-to-hub').addEventListener('click', backToHub);
  document.getElementById('close-shop').addEventListener('click', closeShop);
  document.getElementById('close-binder').addEventListener('click', closeBinder);
  document.getElementById('buy-basic').addEventListener('click', () => buyPack('basic'));
  document.getElementById('buy-premium').addEventListener('click', () => buyPack('premium'));
  document.getElementById('music-button').addEventListener('click', () => {
    playMenuMusic();
    document.getElementById('music-button').style.display = 'none';
  });
});
// ‚îÄ‚îÄ UI HOVER & CLICK SOUND (Your ui-click.mp3) ‚îÄ‚îÄ
function addUISound() {
  const uiElements = document.querySelectorAll('button, .hub-button, .deck-button-blue, .deck-button-red, .close-crypt');
  uiElements.forEach(el => {
    // HOVER: Subtle sound
    el.addEventListener('mouseenter', () => playSound('ui-hover-sound'));
    
    // CLICK: Sharp confirm sound
    el.addEventListener('click', () => playSound('ui-click-sound'));
  });
}
function playSound(id) {
  const s = document.getElementById(id);
  if (s) {
    // Volume levels
    if (id === 'card-hover-sound') s.volume = 0.25;  // Super subtle
    else if (id.includes('hover')) s.volume = 0.2;   // UI hover quiet
    else s.volume = 0.5;  // Game sounds normal
    
    s.currentTime = 0;
    s.play().catch(() => {});
  }
}
// ‚îÄ‚îÄ CARD HOVER SOUND (Hand, Deck, Crypt) ‚îÄ‚îÄ
function addCardHoverSound() {
  // Player hand cards
  document.querySelectorAll('.player-hand .card').forEach(card => {
    card.addEventListener('mouseenter', () => playSound('card-hover-sound'));
    card.addEventListener('mouseleave', () => {}); // Optional: subtle leave sound
  });

  // Deck & Crypt (clickable zones)
  const cardZones = document.querySelectorAll('.player-deck, .opponent-deck, .player-crypt, .opponent-crypt');
  cardZones.forEach(zone => {
    zone.addEventListener('mouseenter', () => playSound('card-hover-sound'));
  });

  // Re-attach when new cards are drawn/played
  const observer = new MutationObserver(() => {
    document.querySelectorAll('.player-hand .card:not([data-hover-sound])').forEach(card => {
      card.dataset.hoverSound = 'true';
      card.addEventListener('mouseenter', () => playSound('card-hover-sound'));
    });
  });
  observer.observe(document.querySelector('.player-hand'), { childList: true, subtree: true });
}

// Run after DOM loads
window.addEventListener('load', () => {
  setTimeout(() => {
    addUISound();
    addCardHoverSound();  // ‚Üê ADD THIS
  }, 500);
});
// ‚îÄ‚îÄ FORCE AUDIO UNLOCK ON FIRST CLICK ‚îÄ‚îÄ
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  audioUnlocked = true;

  // Play a silent sound to "unlock" audio context
  const silent = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
  silent.play().catch(() => {});

  document.removeEventListener('click', unlockAudio);
  document.removeEventListener('touchstart', unlockAudio);
  console.log('Audio unlocked!');
}

// Unlock on first interaction
document.addEventListener('click', unlockAudio, { once: true });
document.addEventListener('touchstart', unlockAudio, { once: true });
/* ---------- SETTINGS POPUP ---------- */
const settingsBtn   = document.getElementById('settings-button');
const settingsPop   = document.getElementById('settings-popup');
const closeSettings = document.getElementById('close-settings');

settingsBtn.addEventListener('click', () => {
  settingsPop.style.display = 'block';
  document.getElementById('hub-container').style.display = 'none';
});
closeSettings.addEventListener('click', () => {
  settingsPop.style.display = 'none';
  document.getElementById('hub-container').style.display = 'flex';
});

/* ---------- VOLUME SLIDERS ---------- */
const uiVolSlider   = document.getElementById('ui-volume');
const uiVolValue    = document.getElementById('ui-volume-value');
const musicVolSlider= document.getElementById('music-volume');
const musicVolValue = document.getElementById('music-volume-value');

/* default volumes (0-1) */
let uiVolume    = 0.5;   // 50%
let musicVolume = 0.3;   // 30%

// load saved values
if (localStorage.getItem('uiVolume'))    uiVolume    = +localStorage.getItem('uiVolume');
if (localStorage.getItem('musicVolume')) musicVolume = +localStorage.getItem('musicVolume');

uiVolSlider.value    = uiVolume    * 100;
musicVolSlider.value = musicVolume * 100;
uiVolValue.textContent    = `${Math.round(uiVolume*100)}%`;
musicVolValue.textContent = `${Math.round(musicVolume*100)}%`;

// UI volume
uiVolSlider.addEventListener('input', () => {
  uiVolume = uiVolSlider.value / 100;
  uiVolValue.textContent = `${uiVolSlider.value}%`;
  localStorage.setItem('uiVolume', uiVolume);
  // all UI sounds use this volume
  ['ui-hover-sound','ui-click-sound','card-hover-sound'].forEach(id => {
    const s = document.getElementById(id);
    if (s) s.volume = uiVolume * 0.4;   // base 0.4 ‚Üí max 0.4
  });
});

// Music volume
musicVolSlider.addEventListener('input', () => {
  musicVolume = musicVolSlider.value / 100;
  musicVolValue.textContent = `${musicVolSlider.value}%`;
  localStorage.setItem('musicVolume', musicVolume);
  menuMusic.volume   = musicVolume;
  battleMusic.volume = musicVolume;
});

/* apply saved volumes on start */
menuMusic.volume   = musicVolume;
battleMusic.volume = musicVolume;

/* modify playSound() to respect UI volume */
function playSound(id) {
  const s = document.getElementById(id);
  if (!s) return;
  s.currentTime = 0;

  // UI sounds
  if (['ui-hover-sound','ui-click-sound','card-hover-sound'].includes(id)) {
    s.volume = uiVolume * 0.4;          // max 0.4
  } else if (id === 'menu-music' || id === 'battle-music') {
    s.volume = musicVolume;
  } else {
    s.volume = 0.5;                     // game SFX
  }
  s.play().catch(() => {});
}
document.getElementById('reset-data').addEventListener('click', () => {
  if (confirm('üóëÔ∏è DELETE EVERYTHING?\n\n‚Ä¢ All Caster Coins\n‚Ä¢ All Cards (Binder + Trunk)\n‚Ä¢ Sound Settings\n\nThis cannot be undone!')) {
    localStorage.clear();
    updateCasterCoins(); // Reset coins display
    showNotification('üóëÔ∏è All data reset! Fresh start!');
    document.getElementById('settings-popup').style.display = 'none';
    document.getElementById('hub-container').style.display = 'flex';
  }
});
</script>
</body>
</html>
