<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Caster's Call</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --gold: #ffd700; --gold-glow: rgba(255,215,0,0.6);
      --blue: #87ceeb; --red: #ff6b6b;
      --bg-dark: #0f0c29; --bg-mid: #302b63; --bg-light: #24243e;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(-45deg, var(--bg-dark), var(--bg-mid), var(--bg-light), var(--bg-dark));
      background-size: 400% 400%; animation: gradient 15s ease infinite;
      color: white; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 10px;
    }
    @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    h1, h2, h3, .game-title-opponent, .game-title-player, .turn-indicator, .card-name { font-family: 'Cinzel', serif; }
    #game {
      position: relative; width: 100%; max-width: 1000px; padding: 30px;
      background: rgba(15,15,25,0.7); border-radius: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.37), 0 0 0 1px rgba(255,215,0,0.1);
      backdrop-filter: blur(12px); border: 1px solid rgba(255,215,0,0.2);
    }
    .game-title-opponent, .game-title-player {
      position: absolute; top: 0; height: 100%; writing-mode: vertical-rl; text-orientation: mixed;
      font-size: 28px; font-weight: bold; color: var(--gold); text-align: center;
      background: rgba(0,0,0,0.5); padding: 10px 5px; border-radius: 8px; text-shadow: 0 0 10px var(--gold-glow);
    }
    .game-title-opponent { left: 8px; } .game-title-player { right: 8px; }
    .turn-info { text-align: center; margin: 15px 0; }
    .turn-indicator {
      display: inline-block; padding: 12px 30px; background: linear-gradient(135deg, #1a1a1a, #333);
      border: 3px solid var(--gold); border-radius: 50px; font-size: 24px; font-weight: bold; color: var(--gold);
      text-shadow: 0 0 10px var(--gold); box-shadow: 0 0 20px rgba(255,215,0,0.4); animation: turn-glow 2s infinite alternate;
    }
    @keyframes turn-glow { from { box-shadow: 0 0 20px rgba(255,215,0,0.4); } to { box-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); } }
    .turn-counter {
      font-size: 18px; font-weight: bold; color: #ffea00; background: rgba(0,0,0,0.7); padding: 6px 14px;
      border: 2px solid #ffea00; border-radius: 50px; display: inline-block; margin-left: 12px; animation: pulse 2s infinite;
    }
    @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }
    .status { display: flex; justify-content: space-between; margin: 12px 0; font-weight: bold; background: rgba(0,0,0,0.5); padding: 12px; border-radius: 8px; align-items: center; flex-wrap: wrap; gap: 10px; }
    .opponent-spell-zones, .opponent-monster-zones, .player-monster-zones, .player-spell-zones {
      display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 10px; flex-wrap: nowrap;
      overflow-x: auto; padding: 8px 0; margin: 10px 0;
    }
    .player-monster-zone, .opponent-monster-zone, .player-spell-zone, .opponent-spell-zone {
      flex: 0 0 auto; width: 126px; height: 174px; min-width: 126px; border: 2px solid var(--gold); border-radius: 12px;
      display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.05); position: relative; transition: all 0.3s;
    }
    .opponent-monster-zone { background: rgba(255,0,0,0.1); }
    .zone {
      display: flex; flex-direction: row; justify-content: flex-start; align-items: center; gap: 10px; overflow-x: auto;
      overflow-y: hidden; padding: 10px; border: 2px dashed #ffd70033; border-radius: 12px; background: rgba(0,0,0,0.3);
      min-height: 180px; backdrop-filter: blur(4px); scrollbar-width: thin; scrollbar-color: #ffd700 #333;
    }
    .zone::-webkit-scrollbar { height: 8px; }
    .zone::-webkit-scrollbar-track { background: #333; border-radius: 4px; }
    .zone::-webkit-scrollbar-thumb { background: #ffd700; border-radius: 4px; }
    .playable-zone { border: 3px solid #00ff00 !important; background: rgba(0,255,0,0.15) !important; box-shadow: 0 0 20px #00ff00 !important; transform: scale(1.05); }
    .card {
      width: 110px; height: 160px; border-radius: 12px; overflow: hidden; position: relative; cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 0 0 3px #000, 0 0 0 5px var(--gold); transition: all 0.3s ease; background: #111 !important;
      transform-style: preserve-3d; perspective: 1000px;
    }
    .card.opponent-hand { cursor: default !important; pointer-events: none; }
    .card::before {
      content: ''; position: absolute; inset: 0; background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.3) 100%);
      pointer-events: none; z-index: 1;
    }
    .card:hover:not(.opponent-hand):not(.has-attacked) {
      transform: translateY(-10px) scale(1.08) rotateX(5deg); box-shadow: 0 20px 40px rgba(0,0,0,0.6), 0 0 0 3px #000, 0 0 0 5px var(--gold), 0 0 20px var(--gold-glow); z-index: 10;
    }
    .card.selected { transform: translateY(-15px) scale(1.12) !important; box-shadow: 0 0 0 4px #00ff00, 0 0 30px #00ff00 !important; }
    .card.playable { box-shadow: 0 0 0 4px #00ff00, 0 0 25px #00ff00 !important; animation: pulse-playable 1.5s infinite; }
    @keyframes pulse-playable { 0%, 100% { box-shadow: 0 0 0 4px #00ff00, 0 0 20px #00ff00; } 50% { box-shadow: 0 0 0 6px #00ff00, 0 0 35px #00ff00; } }
    .card-mana { position: absolute; top: 6px; right: 6px; width: 20px; height: 20px; background: #000; border: 2px solid var(--gold); border-radius: 50%; color: var(--gold); font-weight: bold; font-size: 11px; display: flex; align-items: center; justify-content: center; z-index: 2; box-shadow: 0 0 8px var(--gold-glow); }
    .card .art { position: absolute; top: 12px; left: 8px; right: 8px; height: 80px; border-radius: 8px; overflow: hidden; background: #000; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
    .card .art img { width: 100%; height: 100%; object-fit: cover; }
    .card-name { position: absolute; top: 8px; left: 0; right: 0; font-size: 11px; font-weight: bold; text-align: center; color: var(--gold); text-shadow: 1px 1px 2px #000; z-index: 2; padding: 0 4px; }
    .card-stats { position: absolute; bottom: 6px; left: 6px; right: 6px; background: rgba(0,0,0,0.7); padding: 3px 6px; border-radius: 6px; font-size: 9px; color: #fff; text-align: center; z-index: 2; border: 1px solid var(--gold); }
    .card.opponent-hand::before { background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0.95)) !important; }
    .card.opponent-hand .card-name { color: #666; }
    .card.no-art { background: #333 !important; }
    .card.no-art .art { display: none; }
    .attacking { animation: attackAnim 0.9s ease-out !important; }
    @keyframes attackAnim { 0% { transform: scale(1) translateY(0); } 30% { transform: scale(1.2) translateX(20px); } 60% { transform: scale(0.9) translateX(40px); } 100% { transform: scale(1) translateX(0); } }
    .attacked { animation: damageAnim 0.8s ease-out; }
    @keyframes damageAnim { 0% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.3); filter: brightness(2); } 100% { transform: scale(0); filter: brightness(0); opacity: 0; } }
    .has-attacked { filter: grayscale(50%) brightness(0.7); cursor: not-allowed; }
    .spell-glow { animation: spellGlow 0.8s ease-out; box-shadow: 0 0 30px #00ffff, 0 0 50px #00ffff !important; }
    @keyframes spellGlow { 0% { transform: scale(1); box-shadow: 0 0 10px #00ffff; } 50% { transform: scale(1.15); box-shadow: 0 0 50px #00ffff, 0 0 80px #00ffff; } 100% { transform: scale(1); box-shadow: 0 0 10px #00ffff; } }
    .summon-glow { animation: summonGlow 1.2s ease-out; }
    @keyframes summonGlow { 0% { transform: scale(0.8); opacity: 0; filter: brightness(2); } 50% { transform: scale(1.2); filter: brightness(1.5); } 100% { transform: scale(1); opacity: 1; filter: brightness(1); } }
    .player-deck, .opponent-deck, .player-crypt, .opponent-crypt {
      width: 100px; height: 150px; border: 2px solid var(--gold); border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); font-size: 13px; color: var(--gold); cursor: pointer; transition: all 0.3s;
    }
    .player-deck:hover, .opponent-deck:hover { transform: translateY(-5px); }
    .player-deck.blue-deck, .opponent-deck.blue-deck { background: linear-gradient(to bottom, #172554, #93c5fd); }
    .player-deck.red-deck, .opponent-deck.red-deck { background: linear-gradient(to bottom, #991b1b, #ef4444); }
    .player-crypt, .opponent-crypt { background: linear-gradient(to bottom, #444, #222); }
    .mana-crystals { display: inline-flex; gap: 4px; align-items: center; }
    .mana-crystal { width: 22px; height: 22px; margin: 0 3px; border-radius: 50%; background: #333; border: 2px solid #666; position: relative; transition: all 0.3s; }
    .mana-crystal.filled { background: #00ff00; border-color: #00ff00; box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(255,255,255,0.5); animation: mana-pulse 2s infinite; }
    .mana-crystal.filled.blue { background: var(--blue); box-shadow: 0 0 15px var(--blue), inset 0 0 10px white; }
    .mana-crystal.filled.red { background: var(--red); box-shadow: 0 0 15px var(--red), inset 0 0 10px white; }
    @keyframes mana-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
    button {
      padding: 12px 24px; margin: 8px; border: none; border-radius: 8px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
      cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative; overflow: hidden;
    }
    button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); transition: 0.5s; }
    button:hover::before { left: 100%; } button:hover { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
    #draw-button { background: linear-gradient(135deg, #4facfe, #00f2fe); color: white; }
    #favor-button { background: linear-gradient(135deg, #ff6b6b, #ee5a52); color: white; }
    #attack-button { background: linear-gradient(135deg, #ff9a56, #ff6b6b); color: white; }
    button#end-turn { background: linear-gradient(135deg, #333, #111); color: var(--gold); }
    #deck-selection-popup, #game-over-popup, #player-crypt-popup, #opponent-crypt-popup {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px;
      border: 3px solid var(--gold); border-radius: 16px; text-align: center; color: var(--gold); font-size: 24px; font-weight: bold; z-index: 1000;
      box-shadow: 0 0 40px rgba(255,215,0,0.4);
    }
    .deck-button-blue, .deck-button-red { background: linear-gradient(to bottom, #87ceeb, #4682b4); color: white; border: 2px solid var(--gold); margin: 15px; padding: 18px 36px; font-size: 22px; border-radius: 12px; }
    .deck-button-red { background: linear-gradient(to bottom, #ff9999, #cc6666); }
    .card-tooltip {
      position: absolute; background: linear-gradient(135deg, #1a1a1a, #2d2d2d); border: 2px solid var(--gold); border-radius: 12px; padding: 16px; max-width: 280px;
      font-size: 14px; color: var(--gold); box-shadow: 0 10px 30px rgba(0,0,0,0.6); z-index: 1002; opacity: 0; visibility: hidden; transform: translateY(10px);
      transition: all 0.3s ease; pointer-events: none;
    }
    .card-tooltip.show { opacity: 1; visibility: visible; transform: translateY(0); }
    .card-tooltip h3 { margin: 0 0 8px; font-size: 18px; color: #fff; }
    #notification {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: var(--gold); padding: 12px 24px;
      border: 2px solid var(--gold); border-radius: 50px; font-size: 18px; font-weight: bold; z-index: 1001; opacity: 0; transition: opacity .5s; pointer-events: none;
      box-shadow: 0 0 20px rgba(255,215,0,0.4);
    }
    #notification.show { opacity: 1; }
    @keyframes particle { to { transform: translateY(-120px) scale(0); opacity: 0; } }
    @media (max-width: 768px) {
      #game { padding: 15px; }
      .card { width: 90px; height: 130px; }
      .player-monster-zone, .opponent-monster-zone, .player-spell-zone, .opponent-spell-zone { width: 100px; height: 140px; }
      .turn-indicator { font-size: 20px; padding: 10px 20px; }
    }
    .ai-attack-target { box-shadow: 0 0 0 4px #ff0000, 0 0 30px #ff0000 !important; animation: aiTargetPulse 1s infinite; }
    @keyframes aiTargetPulse { 0%, 100% { box-shadow: 0 0 0 4px #ff0000, 0 0 20px #ff0000; } 50% { box-shadow: 0 0 0 6px #ff0000, 0 0 40px #ff0000; } }
  </style>
</head>
<body>
<div id="game">
  <div class="game-title-opponent">Caster's Call</div>
  <div class="game-title-player">Caster's Call</div>
  <div class="turn-info">
    <div class="turn-indicator" id="turn-indicator">Player's Turn</div>
    <div class="turn-counter" id="turn-counter">Turn 1</div>
  </div>
  <div class="status">
    <span id="opponent-life">Opponent Life: 20</span>
    <div id="opponent-mana-crystals" class="mana-crystals"></div>
  </div>
  <div class="opponent-hand-container">
    <div class="opponent-deck" id="opponent-deck">Deck: 30</div>
    <div class="opponent-crypt" id="opponent-crypt">Crypt: 0</div>
    <div class="opponent-hand zone"></div>
  </div>
  <div class="opponent-spell-zones">
    <div class="opponent-spell-zone" id="opponent-spell-zone-1"></div>
    <div class="opponent-spell-zone" id="opponent-spell-zone-2"></div>
    <div class="opponent-spell-zone" id="opponent-spell-zone-3"></div>
  </div>
  <div class="opponent-monster-zones">
    <div class="opponent-monster-zone" id="opponent-monster-zone-1"></div>
    <div class="opponent-monster-zone" id="opponent-monster-zone-2"></div>
    <div class="opponent-monster-zone" id="opponent-monster-zone-3"></div>
    <div class="opponent-monster-zone" id="opponent-monster-zone-4"></div>
    <div class="opponent-monster-zone" id="opponent-monster-zone-5"></div>
  </div>
  <div class="player-monster-zones">
    <div class="player-monster-zone" id="player-monster-zone-1"></div>
    <div class="player-monster-zone" id="player-monster-zone-2"></div>
    <div class="player-monster-zone" id="player-monster-zone-3"></div>
    <div class="player-monster-zone" id="player-monster-zone-4"></div>
    <div class="player-monster-zone" id="player-monster-zone-5"></div>
  </div>
  <div class="player-spell-zones">
    <div class="player-spell-zone" id="player-spell-zone-1"></div>
    <div class="player-spell-zone" id="player-spell-zone-2"></div>
    <div class="player-spell-zone" id="player-spell-zone-3"></div>
  </div>
  <div class="player-hand-container">
    <div class="player-hand zone"></div>
    <div class="player-deck" id="player-deck">Deck: 30</div>
    <div class="player-crypt" id="player-crypt">Crypt: 0</div>
  </div>
  <div class="status">
    <span id="player-life">Player Life: 20</span>
    <div id="player-mana-crystals" class="mana-crystals"></div>
  </div>
  <div style="text-align:center; margin-top:15px;">
    <button onclick="playerDraw()" id="draw-button">Draw</button>
    <button onclick="useFavor()" id="favor-button">Favor</button>
    <button onclick="startAttackPhase()" id="attack-button">Attack</button>
    <button onclick="endTurn()" id="end-turn">End Turn</button>
    <button onclick="attackLifePoints()" id="attack-life-button" style="display: none;">Attack Life</button>
  </div>
  <div id="deck-selection-popup">
    <div>Choose Your Starting Deck</div>
    <button class="deck-button-blue">Blue</button>
    <button class="deck-button-red">Red</button>
  </div>
  <div id="game-over-popup">
    <div id="game-over-text"></div>
    <button onclick="resetGame(); document.getElementById('game-over-popup').style.display='none';">Retry</button>
  </div>
  <div id="player-crypt-popup">
    <div>Player's Crypt</div>
    <div id="player-crypt-content"></div>
    <button class="close-crypt" onclick="closeCryptPopup()">X</button>
  </div>
  <div id="opponent-crypt-popup">
    <div>Opponent's Crypt</div>
    <div id="opponent-crypt-content"></div>
    <button class="close-crypt" onclick="closeCryptPopup()">X</button>
  </div>
  <div id="notification"></div>
  <div id="tooltip" class="card-tooltip"></div>
  <audio id="draw-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/472926__srinivasan__card-shuffle.mp3"></audio>
  <audio id="play-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/472925__srinivasan__card-place.mp3"></audio>
  <audio id="attack-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/416179__jorgeolvera__sword-hit.mp3"></audio>
  <audio id="spell-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/346689__natef006__magic.mp3"></audio>
  <audio id="turn-sound" src="https://cdn.jsdelivr.net/gh/freesound/freesound-api@master/sounds/387233__daronious__chime.mp3"></audio>
</div>

<script>
// ────────────────────────────────────────────────────────────────────────
// FULL GAME LOGIC – WITH AI ATTACKS (SUGGESTION #8)
// ────────────────────────────────────────────────────────────────────────
let playerLife = 20, opponentLife = 20;
let playerMana = 1, opponentMana = 1;
let turn = "player", attackPhase = false;
let hasDrawn = false, hasUsedFavor = false;
let selectedCard = null;
let playerDeck = [], opponentDeck = [], playerHand = [], opponentHand = [];
let playerPlayedCards = [], opponentPlayedCards = [], playerSpellField = [], opponentSpellField = [];
let playerCrypt = [], opponentCrypt = [];
let isOpponentTurnProcessing = false;
let playerDeckColor = null, opponentDeckColor = null;
let turnCount = 1;
const maxHandSize = 7;
const tooltip = document.getElementById('tooltip');
let selectedHandCard = null;

const blueCardTemplates = [
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Holy Lamb", type: "creature", atk: 1, def: 1, mana: 0, art: "holy-lamb.png" },
  { name: "Oracle of Light", type: "creature", atk: 2, def: 2, mana: 1, art: "oracle-light.png" },
  { name: "Oracle of Light", type: "creature", atk: 2, def: 2, mana: 1, art: "oracle-light.png" },
  { name: "Priestess of Dawn", type: "creature", atk: 1, def: 3, mana: 1, art: "priestess-dawn.png" },
  { name: "Priestess of Dawn", type: "creature", atk: 1, def: 3, mana: 1, art: "priestess-dawn.png" },
  { name: "Sacred Maiden", type: "creature", atk: 1, def: 2, mana: 1, art: "sacred-maiden.png" },
  { name: "Sacred Maiden", type: "creature", atk: 1, def: 2, mana: 1, art: "sacred-maiden.png" },
  { name: "Great Prophet", type: "creature", atk: 5, def: 4, mana: 2, art: "great-prophet.png" },
  { name: "Great Prophet", type: "creature", atk: 5, def: 4, mana: 2, art: "great-prophet.png" },
  { name: "Prize Fighter", type: "creature", atk: 4, def: 4, mana: 2, art: "prize-fighter.png" },
  { name: "Prize Fighter", type: "creature", atk: 4, def: 4, mana: 2, art: "prize-fighter.png" },
  { name: "Royal Paladin", type: "creature", atk: 4, def: 2, mana: 2, art: "royal-paladin.png" },
  { name: "Royal Paladin", type: "creature", atk: 4, def: 2, mana: 2, art: "royal-paladin.png" },
  { name: "Templar Guardian", type: "creature", atk: 3, def: 5, mana: 2, art: "templar-guardian.png" },
  { name: "Templar Guardian", type: "creature", atk: 3, def: 5, mana: 2, art: "templar-guardian.png" },
  { name: "Holy King", type: "creature", atk: 6, def: 6, mana: 3, art: "holy-king.png" },
  { name: "Holy King", type: "creature", atk: 6, def: 6, mana: 3, art: "holy-king.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Royal Decree", type: "spell", effect: "Deal 2 damage", mana: 0, art: "royal-decree.png" },
  { name: "Royal Decree", type: "spell", effect: "Deal 2 damage", mana: 0, art: "royal-decree.png" },
  { name: "Divine Blessing", type: "spell", effect: "Restore 3 life", mana: 1, art: "divine-blessing.png" },
  { name: "Divine Blessing", type: "spell", effect: "Restore 3 life", mana: 1, art: "divine-blessing.png" },
  { name: "Light of Salvation", type: "spell", effect: "Deal 3 damage", mana: 1, art: "light-salvation.png" },
  { name: "Light of Salvation", type: "spell", effect: "Deal 3 damage", mana: 1, art: "light-salvation.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" }
];

const redCardTemplates = [
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Flame Kobold", type: "creature", atk: 1, def: 1, mana: 0, art: "flame-kobold.png" },
  { name: "Red Wyvern", type: "creature", atk: 1, def: 3, mana: 1, art: "red-wyvern.png" },
  { name: "Red Wyvern", type: "creature", atk: 1, def: 3, mana: 1, art: "red-wyvern.png" },
  { name: "Rogue Outlaw", type: "creature", atk: 2, def: 2, mana: 1, art: "rogue-outlaw.png" },
  { name: "Rogue Outlaw", type: "creature", atk: 2, def: 2, mana: 1, art: "rogue-outlaw.png" },
  { name: "Shadow Bandit", type: "creature", atk: 3, def: 1, mana: 1, art: "shadow-bandit.png" },
  { name: "Shadow Bandit", type: "creature", atk: 3, def: 1, mana: 1, art: "shadow-bandit.png" },
  { name: "Berserker Chieftain", type: "creature", atk: 3, def: 3, mana: 2, art: "berserker.png" },
  { name: "Berserker Chieftain", type: "creature", atk: 3, def: 3, mana: 2, art: "berserker.png" },
  { name: "Crimson Wyrm", type: "creature", atk: 4, def: 2, mana: 2, art: "crimson-wyrm.png" },
  { name: "Crimson Wyrm", type: "creature", atk: 4, def: 2, mana: 2, art: "crimson-wyrm.png" },
  { name: "Dragon Knight", type: "creature", atk: 5, def: 3, mana: 2, art: "dragon-knight.png" },
  { name: "Dragon Knight", type: "creature", atk: 5, def: 3, mana: 2, art: "dragon-knight.png" },
  { name: "Flame Marauder", type: "creature", atk: 4, def: 3, mana: 2, art: "flame-marauder.png" },
  { name: "Flame Marauder", type: "creature", atk: 4, def: 3, mana: 2, art: "flame-marauder.png" },
  { name: "Draco Emperor", type: "creature", atk: 6, def: 6, mana: 3, art: "draco-emperor.png" },
  { name: "Draco Emperor", type: "creature", atk: 6, def: 6, mana: 3, art: "draco-emperor.png" },
  { name: "Ambush Strike", type: "spell", effect: "Deal 2 damage", mana: 0, art: "ambush-strike.png" },
  { name: "Ambush Strike", type: "spell", effect: "Deal 2 damage", mana: 0, art: "ambush-strike.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Draw", type: "spell", effect: "Draw 2 cards", mana: 0, art: "draw-spell.png" },
  { name: "Dragon's Breath", type: "spell", effect: "Deal 3 damage", mana: 1, art: "dragons-breath.png" },
  { name: "Dragon's Breath", type: "spell", effect: "Deal 3 damage", mana: 1, art: "dragons-breath.png" },
  { name: "Fiery Surge", type: "spell", effect: "Restore 3 life", mana: 1, art: "fiery-surge.png" },
  { name: "Fiery Surge", type: "spell", effect: "Restore 3 life", mana: 1, art: "fiery-surge.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" },
  { name: "Resurrection", type: "spell", effect: "Revive a monster from the Crypt", mana: 2, art: "resurrection.png" }
];

// ── HELPERS ──
function playSound(id) { const s = document.getElementById(id); if (s) { s.currentTime = 0; s.play().catch(() => {}); } }
function showNotification(msg) { const n = document.getElementById('notification'); n.innerText = msg; n.classList.add('show'); setTimeout(() => n.classList.remove('show'), 3000); }
function addParticles(el) {
  for (let i = 0; i < 10; i++) {
    const p = document.createElement('div');
    p.style.cssText = `position: absolute; width: 6px; height: 6px; background: #00ff00; border-radius: 50%; pointer-events: none; z-index: 5; left: ${50 + (Math.random()-0.5)*60}px; top: ${80 + (Math.random()-0.5)*40}px; animation: particle 0.8s ease-out forwards;`;
    el.appendChild(p); setTimeout(() => p.remove(), 800);
  }
}
function addTooltipListeners(div, card) {
  div.onmouseenter = () => {
    tooltip.innerHTML = `<h3>${card.name}</h3><div>Type: ${card.type} | Mana: ${card.mana}</div>${card.atk ? `<div>ATK: ${card.atk} | DEF: ${card.def}</div>` : ''}${card.effect ? `<div class="effect">${card.effect}</div>` : ''}`;
    tooltip.style.left = (event.pageX + 15) + 'px'; tooltip.style.top = (event.pageY - 10) + 'px'; tooltip.classList.add('show');
  };
  div.onmouseleave = () => tooltip.classList.remove('show');
  div.onmousemove = e => { tooltip.style.left = (e.pageX + 15) + 'px'; tooltip.style.top = (e.pageY - 10) + 'px'; };
}
function updateHandPlayability() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    const c = playerHand.find(x => x.id === div.dataset.id);
    if (c && c.mana <= playerMana) { div.classList.add("playable"); div.classList.remove("unplayable"); }
    else { div.classList.add("unplayable"); div.classList.remove("playable"); }
  });
}
function updateTurnDisplay() {
  document.getElementById("turn-indicator").innerText = turn === "player" ? "Player's Turn" : "Opponent's Turn";
  document.getElementById("turn-counter").innerText = `Turn ${turnCount}`;
}
function renderManaCrystals(id, mana, max = 10, color = null) {
  const c = document.getElementById(id); c.innerHTML = '';
  for (let i = 0; i < max; i++) {
    const crystal = document.createElement('div');
    crystal.className = 'mana-crystal';
    if (i < mana) { crystal.classList.add('filled'); if (color) crystal.classList.add(color); }
    c.appendChild(crystal);
  }
}
function updateManaDisplays() {
  renderManaCrystals('player-mana-crystals', playerMana, 10, playerDeckColor?.toLowerCase());
  renderManaCrystals('opponent-mana-crystals', opponentMana, 10, opponentDeckColor?.toLowerCase());
}
function showDeckSelectionPopup() {
  const popup = document.getElementById("deck-selection-popup");
  popup.style.display = "block";
  document.querySelector(".deck-button-blue").onclick = () => selectDeck('Blue');
  document.querySelector(".deck-button-red").onclick = () => selectDeck('Red');
  showNotification("Choose your deck!");
}
function selectDeck(color) {
  playerDeckColor = color;
  opponentDeckColor = color === "Blue" ? "Red" : "Blue";
  document.getElementById("player-deck").className = `player-deck ${color.toLowerCase()}-deck`;
  document.getElementById("opponent-deck").className = `opponent-deck ${opponentDeckColor.toLowerCase()}-deck`;
  document.getElementById("deck-selection-popup").style.display = "none";
  setupBoard();
}
function createDeck(isBlue) {
  const t = isBlue ? blueCardTemplates : redCardTemplates;
  let d = t.map((c, i) => ({ ...c, id: `${c.name}-${i}-${Date.now()}`, hasAttacked: c.type === "creature" ? false : undefined }));
  for (let i = d.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [d[i], d[j]] = [d[j], d[i]]; }
  return d;
}
function drawCard(deck, hand, zoneCls) {
  if (deck.length === 0 || hand.length >= maxHandSize) return;
  const card = deck.splice(Math.floor(Math.random() * deck.length), 1)[0];
  hand.push(card);
  const zone = document.querySelector(zoneCls);
  const div = document.createElement("div");
  div.className = zoneCls.includes("opponent") ? "card opponent-hand" : "card";
  div.draggable = !zoneCls.includes("opponent");
  div.dataset.id = card.id;
  const isOpponentHand = zoneCls.includes("opponent");
  if (card.art) {
    const img = new Image();
    img.onload = () => { div.style.backgroundImage = `url('images/${card.art}')`; if (isOpponentHand) div.style.filter = "brightness(0.3)"; };
    img.onerror = () => div.classList.add('no-art');
    img.src = `images/${card.art}`;
  } else { div.classList.add('no-art'); }
  div.innerHTML = `
    <div class="card-mana">${card.mana}</div>
    <div class="art"><img src="images/${card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div>
    <div class="card-name">${isOpponentHand ? "??" : card.name}</div>
    ${!isOpponentHand ? `<div class="card-stats">${card.atk ? `ATK ${card.atk} | DEF ${card.def}` : card.effect || ''}</div>` : ''}
  `;
  if (!isOpponentHand) addTooltipListeners(div, card);
  zone.appendChild(div);
  playSound("draw-sound");
  if (zoneCls === ".player-hand") { updatePlayerDeck(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners(); } else updateOpponentDeck();
}
function updatePlayerDeck() { document.querySelector(".player-deck").innerText = `${playerDeckColor}: ${playerDeck.length}`; }
function updateOpponentDeck() { document.querySelector(".opponent-deck").innerText = `${opponentDeckColor}: ${opponentDeck.length}`; }
function updatePlayerCrypt() { document.querySelector(".player-crypt").innerText = `Crypt: ${playerCrypt.length}`; }
function updateOpponentCrypt() { document.querySelector(".opponent-crypt").innerText = `Crypt: ${opponentCrypt.length}`; }
function setupBoard() {
  playerDeck = createDeck(playerDeckColor === "Blue");
  opponentDeck = createDeck(opponentDeckColor === "Blue");
  playerHand = []; opponentHand = [];
  for (let i = 0; i < 4; i++) { drawCard(playerDeck, playerHand, ".player-hand"); drawCard(opponentDeck, opponentHand, ".opponent-hand"); }
  turn = Math.random() < 0.5 ? "player" : "opponent";
  turnCount = 1; updateTurnDisplay();
  document.getElementById("draw-button").disabled = turn !== "player";
  updateManaDisplays();
  if (turn === "opponent") opponentTurn();
}
function updatePlayerZone() {
  for (let i = 1; i <= 5; i++) {
    const zone = document.getElementById(`player-monster-zone-${i}`);
    zone.innerHTML = "";
    const entry = playerPlayedCards.find(e => e.zone === zone.id);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = `card played ${entry.card.hasAttacked ? 'has-attacked' : ''}`;
      cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-mana">${entry.card.mana}</div><div class="art"><img src="images/${entry.card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div><div class="card-name">${entry.card.name}</div><div class="card-stats">ATK: ${entry.card.atk} DEF: ${entry.card.def}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      if (attackPhase && !entry.card.hasAttacked) {
        cardDiv.classList.add('attackable'); cardDiv.style.cursor = "pointer"; cardDiv.onclick = selectPlayerCard;
      } else { cardDiv.classList.remove('attackable'); cardDiv.style.cursor = "default"; cardDiv.onclick = null; }
      zone.appendChild(cardDiv);
    }
  }
}
function updateOpponentZone() {
  for (let i = 1; i <= 5; i++) {
    const zone = document.getElementById(`opponent-monster-zone-${i}`);
    zone.innerHTML = "";
    const entry = opponentPlayedCards.find(e => e.zone === `opponent-monster-zone-${i}`);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = `card opponent played ${entry.card.hasAttacked ? 'has-attacked' : ''}`;
      cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-mana">${entry.card.mana}</div><div class="art"><img src="images/${entry.card.art}" onerror="this.style.display='none'; this.parentElement.style.background='#333'"></div><div class="card-name">${entry.card.name}</div><div class="card-stats">ATK: ${entry.card.atk} DEF: ${entry.card.def}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      if (attackPhase && selectedCard && !selectedCard.hasAttacked) {
        cardDiv.classList.add('attack-target'); cardDiv.style.cursor = "crosshair"; cardDiv.onclick = handlePlayerAttack;
      } else { cardDiv.classList.remove('attack-target'); cardDiv.style.cursor = "default"; cardDiv.onclick = null; }
      zone.appendChild(cardDiv);
    }
  }
}
function updatePlayerSpellZone() {
  for (let i = 1; i <= 3; i++) {
    const zone = document.getElementById(`player-spell-zone-${i}`);
    zone.innerHTML = "";
    const entry = playerSpellField.find(e => e.zone === zone.id);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = "card spell"; cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-name">${entry.card.name}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      zone.appendChild(cardDiv);
    }
  }
}
function updateOpponentSpellZone() {
  for (let i = 1; i <= 3; i++) {
    const zone = document.getElementById(`opponent-spell-zone-${i}`);
    zone.innerHTML = "";
    const entry = opponentSpellField.find(e => e.zone === `opponent-spell-zone-${i}`);
    if (entry) {
      const cardDiv = document.createElement("div");
      cardDiv.className = "card opponent spell"; cardDiv.dataset.id = entry.card.id;
      if (entry.card.art) {
        const img = new Image();
        img.onload = () => cardDiv.style.backgroundImage = `url('images/${entry.card.art}')`;
        img.onerror = () => cardDiv.classList.add('no-art');
        img.src = `images/${entry.card.art}`;
      } else cardDiv.classList.add('no-art');
      cardDiv.innerHTML = `<div class="card-name">${entry.card.name}</div>`;
      addTooltipListeners(cardDiv, entry.card);
      zone.appendChild(cardDiv);
    }
  }
}
function trySelectCardFromHand(div) {
  if (turn !== "player" || attackPhase) return;
  if (selectedHandCard) selectedHandCard.classList.remove('selected'); selectedHandCard = null;
  const id = div.dataset.id;
  const card = playerHand.find(c => c.id === id);
  if (!card || card.mana > playerMana) { showNotification("Not enough mana!"); return; }
  selectedHandCard = div; div.classList.add('selected');
  showNotification(`Selected: ${card.name} - Click a zone to play`);
  highlightAvailableZones(card.type);
}
function highlightAvailableZones(cardType) {
  document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; });
  if (cardType === "creature") {
    for (let i = 1; i <= 5; i++) {
      const zone = document.getElementById(`player-monster-zone-${i}`);
      if (!playerPlayedCards.some(p => p.zone === zone.id)) {
        zone.classList.add('playable-zone');
        zone.onclick = () => playCardToZone(selectedHandCard, zone.id);
      }
    }
  } else if (cardType === "spell") {
    for (let i = 1; i <= 3; i++) {
      const zone = document.getElementById(`player-spell-zone-${i}`);
      if (!playerSpellField.some(p => p.zone === zone.id)) {
        zone.classList.add('playable-zone');
        zone.onclick = () => playCardToZone(selectedHandCard, zone.id);
      }
    }
  }
}
function playCardToZone(cardDiv, targetZoneId) {
  if (!selectedHandCard) return;
  const id = cardDiv.dataset.id;
  const card = playerHand.find(c => c.id === id);
  if (!card) return;
  document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; });
  selectedHandCard.classList.remove('selected'); selectedHandCard = null;
  if (card.type === "creature") {
    if (playerMana < card.mana || playerPlayedCards.some(p => p.zone === targetZoneId)) return;
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id); cardDiv.remove();
    card.hasAttacked = false; playerPlayedCards.push({ card, zone: targetZoneId });
    updatePlayerZone(); updateOpponentZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const newC = document.getElementById(targetZoneId).querySelector('.card');
    if (newC) { addParticles(newC); playSound('play-sound'); }
    checkGameOver();
  } else if (card.type === "spell") {
    if (playerMana < card.mana || playerSpellField.some(p => p.zone === targetZoneId)) return;
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id); cardDiv.remove();
    playerSpellField.push({ card, zone: targetZoneId });
    updatePlayerSpellZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const spellC = document.querySelector(`#${targetZoneId} .card`);
    if (spellC) {
      spellC.classList.add('spell-glow'); playSound('spell-sound');
      setTimeout(() => {
        playerSpellField = playerSpellField.filter(e => e.card.id !== card.id);
        playerCrypt.push(card); updatePlayerCrypt(); updatePlayerSpellZone(); updatePlayerZone(); updateOpponentZone();
        spellC.classList.remove('spell-glow');
        if (card.effect === "Restore 3 life") { playerLife += 3; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; opponentLife -= dmg; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let j = 0; j < 2 && playerHand.length < maxHandSize && playerDeck.length > 0; j++) drawCard(playerDeck, playerHand, ".player-hand"); }
        else if (card.effect === "Revive a monster from the Crypt") {
          const rev = playerCrypt.find(c => c.type === "creature");
          if (rev) {
            let empty = null;
            for (let k = 1; k <= 5; k++) if (!playerPlayedCards.find(p => p.zone === `player-monster-zone-${k}`)) { empty = `player-monster-zone-${k}`; break; }
            if (empty) { playerCrypt = playerCrypt.filter(c => c.id !== rev.id); rev.hasAttacked = false; playerPlayedCards.push({ card: rev, zone: empty }); updatePlayerCrypt(); updatePlayerZone(); updateOpponentZone(); }
          }
        }
        checkGameOver();
      }, 800);
    }
  }
}
function attachHandClickListeners() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    if (!div.dataset.clickListener) {
      div.dataset.clickListener = "true"; div.style.cursor = "pointer"; div.title = "Click to select";
      div.addEventListener("click", () => trySelectCardFromHand(div));
    }
  });
}
function makeHandDraggable() {
  document.querySelectorAll(".player-hand .card").forEach(div => {
    if (!div.dataset.dragListener) {
      div.draggable = true; div.dataset.dragListener = "true";
      div.addEventListener("dragstart", e => { if (turn === "player" && !attackPhase) e.dataTransfer.setData("text", div.dataset.id); });
    }
  });
  attachHandClickListeners();
}
for (let i = 1; i <= 5; i++) {
  const zone = document.getElementById(`player-monster-zone-${i}`);
  zone.addEventListener("dragover", e => e.preventDefault());
  zone.addEventListener("drop", e => {
    e.preventDefault(); if (turn !== "player" || attackPhase) return;
    const id = e.dataTransfer.getData("text");
    const card = playerHand.find(c => c.id === id);
    if (!card || card.type !== "creature" || playerMana < card.mana || playerPlayedCards.some(p => p.zone === zone.id)) return;
    if (selectedHandCard) { selectedHandCard.classList.remove('selected'); selectedHandCard = null; document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; }); }
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id);
    document.querySelector(`.player-hand .card[data-id="${id}"]`)?.remove();
    card.hasAttacked = false; playerPlayedCards.push({ card, zone: zone.id });
    updatePlayerZone(); updateOpponentZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const newC = zone.querySelector(".card"); if (newC) { addParticles(newC); playSound('play-sound'); }
    checkGameOver();
  });
}
for (let i = 1; i <= 3; i++) {
  const zone = document.getElementById(`player-spell-zone-${i}`);
  zone.addEventListener("dragover", e => e.preventDefault());
  zone.addEventListener("drop", e => {
    e.preventDefault(); if (turn !== "player" || attackPhase) return;
    const id = e.dataTransfer.getData("text");
    const card = playerHand.find(c => c.id === id);
    if (!card || card.type !== "spell" || playerMana < card.mana || playerSpellField.some(p => p.zone === zone.id)) return;
    if (selectedHandCard) { selectedHandCard.classList.remove('selected'); selectedHandCard = null; document.querySelectorAll('.player-monster-zone, .player-spell-zone').forEach(z => { z.classList.remove('playable-zone'); z.onclick = null; }); }
    playerMana -= card.mana; updateManaDisplays();
    playerHand = playerHand.filter(c => c.id !== id);
    document.querySelector(`.player-hand .card[data-id="${id}"]`)?.remove();
    playerSpellField.push({ card, zone: zone.id });
    updatePlayerSpellZone(); updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
    const spellC = zone.querySelector('.card');
    if (spellC) {
      spellC.classList.add('spell-glow'); playSound('spell-sound');
      setTimeout(() => {
        playerSpellField = playerSpellField.filter(e => e.card.id !== card.id);
        playerCrypt.push(card); updatePlayerCrypt(); updatePlayerSpellZone(); updatePlayerZone(); updateOpponentZone();
        spellC.classList.remove('spell-glow');
        if (card.effect === "Restore 3 life") { playerLife += 3; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; opponentLife -= dmg; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let j = 0; j < 2 && playerHand.length < maxHandSize && playerDeck.length > 0; j++) drawCard(playerDeck, playerHand, ".player-hand"); }
        else if (card.effect === "Revive a monster from the Crypt") {
          const rev = playerCrypt.find(c => c.type === "creature");
          if (rev) {
            let empty = null;
            for (let k = 1; k <= 5; k++) if (!playerPlayedCards.find(p => p.zone === `player-monster-zone-${k}`)) { empty = `player-monster-zone-${k}`; break; }
            if (empty) { playerCrypt = playerCrypt.filter(c => c.id !== rev.id); rev.hasAttacked = false; playerPlayedCards.push({ card: rev, zone: empty }); updatePlayerCrypt(); updatePlayerZone(); updateOpponentZone(); }
          }
        }
        checkGameOver();
      }, 800);
    }
  });
}
function useFavor() {
  if (turn !== "player" || hasUsedFavor || attackPhase) return;
  playerMana += 1; playerLife -= 1; updateManaDisplays();
  document.getElementById("player-life").innerText = `Player Life: ${playerLife}`;
  hasUsedFavor = true; document.getElementById("favor-button").disabled = true; document.getElementById("favor-button").innerText = "Favor (Used)";
  playSound("spell-sound"); showNotification("You sacrificed life for mana!"); checkGameOver();
}
function startAttackPhase() {
  if (turn !== "player" || attackPhase) return;
  attackPhase = true;
  document.getElementById("attack-button").disabled = true;
  const canAttack = playerPlayedCards.some(e => !e.card.hasAttacked);
  document.getElementById("attack-life-button").style.display = (canAttack && opponentPlayedCards.length === 0) ? "inline" : "none";
  updatePlayerZone(); updateOpponentZone();
  showNotification("Attack phase! Click your monster, then opponent's monster or life.");
}
function selectPlayerCard(e) {
  const cardId = e.target.dataset.id;
  const entry = playerPlayedCards.find(e => e.card.id === cardId);
  if (!entry || entry.card.hasAttacked) return;
  if (selectedCard) document.querySelector(`.card[data-id="${selectedCard.id}"]`)?.classList.remove("selected");
  selectedCard = entry.card;
  e.target.classList.add("selected");
  updateOpponentZone();
}
function handlePlayerAttack(e) {
  if (!selectedCard || selectedCard.hasAttacked) return;
  const targetId = e.target.dataset.id;
  const target = opponentPlayedCards.find(e => e.card.id === targetId);
  if (!target) return;
  const attacker = document.querySelector(`.card[data-id="${selectedCard.id}"]`);
  attacker.classList.add('attacking'); playSound("attack-sound");
  setTimeout(() => {
    attacker.classList.remove('attacking'); attacker.classList.add('has-attacked');
  }, 900);
  if (selectedCard.atk >= target.card.def) {
    opponentPlayedCards = opponentPlayedCards.filter(e => e.card.id !== targetId);
    opponentCrypt.push(target.card); updateOpponentCrypt();
  }
  selectedCard.hasAttacked = true; selectedCard = null;
  document.getElementById("attack-life-button").style.display = opponentPlayedCards.length === 0 ? "inline" : "none";
  updatePlayerZone(); updateOpponentZone(); checkGameOver();
}
function attackLifePoints() {
  if (!selectedCard || selectedCard.hasAttacked) return;
  const damage = selectedCard.atk;
  opponentLife -= damage; document.getElementById("opponent-life").innerText = `Opponent Life: ${opponentLife}`;
  selectedCard.hasAttacked = true; document.querySelector(`.card[data-id="${selectedCard.id}"]`).classList.add('has-attacked');
  selectedCard = null; updatePlayerZone(); checkGameOver();
}
function endTurn() {
  if (attackPhase) {
    attackPhase = false; document.getElementById("attack-button").disabled = false;
    document.getElementById("attack-life-button").style.display = "none"; selectedCard = null;
  }
  playerPlayedCards.forEach(e => { if (e.card.type === "creature") e.card.hasAttacked = false; });
  opponentPlayedCards.forEach(e => { if (e.card.type === "creature") e.card.hasAttacked = false; });
  turn = turn === "player" ? "opponent" : "player"; turnCount++;
  if (turn === "player") playerMana = Math.min(playerMana + 1, 10); else opponentMana = Math.min(opponentMana + 1, 10);
  updateManaDisplays(); playSound("turn-sound");
  if (turn === "player") {
    hasDrawn = false; hasUsedFavor = false;
    document.getElementById("draw-button").disabled = false;
    document.getElementById("favor-button").disabled = false; document.getElementById("favor-button").innerText = "Favor";
    document.getElementById("attack-button").disabled = false;
    updateTurnDisplay(); updatePlayerZone(); updateOpponentZone(); updatePlayerSpellZone(); updateOpponentSpellZone();
    updateHandPlayability(); makeHandDraggable(); attachHandClickListeners();
  } else opponentTurn();
}
function playerDraw() {
  if (turn !== "player" || hasDrawn || attackPhase || playerHand.length >= maxHandSize) return;
  drawCard(playerDeck, playerHand, ".player-hand"); hasDrawn = true; document.getElementById("draw-button").disabled = true;
}
function checkGameOver() {
  if (playerLife <= 0) { document.getElementById("game-over-text").innerText = "You Lose!"; document.getElementById("game-over-popup").style.display = "block"; }
  else if (opponentLife <= 0) { document.getElementById("game-over-text").innerText = "You Win!"; document.getElementById("game-over-popup").style.display = "block"; }
}
function resetGame() { location.reload(); }
function closeCryptPopup() {
  document.getElementById('player-crypt-popup').style.display = 'none';
  document.getElementById('opponent-crypt-popup').style.display = 'none';
}

// ── AI TURN WITH ATTACKS ──
function opponentTurn() {
  if (isOpponentTurnProcessing) return; isOpponentTurnProcessing = true;
  drawCard(opponentDeck, opponentHand, ".opponent-hand");
  let played = 0; const maxPlays = Math.min(3, opponentMana);
  const tryPlay = () => {
    if (played >= maxPlays || opponentMana <= 0) { setTimeout(opponentAttackPhase, 800); return; }
    const playable = opponentHand.filter(c => c.mana <= opponentMana);
    if (playable.length === 0) { setTimeout(opponentAttackPhase, 800); return; }
    const card = playable.sort((a,b) => b.mana - a.mana)[0];
    const idx = opponentHand.indexOf(card);
    opponentPlayCard(card, idx); played++;
    setTimeout(tryPlay, 1000);
  };
  setTimeout(tryPlay, 800);
}
function opponentAttackPhase() {
  const attackers = opponentPlayedCards.filter(e => !e.card.hasAttacked);
  if (attackers.length === 0) { setTimeout(() => { isOpponentTurnProcessing = false; endTurn(); }, 800); return; }
  const attackNext = () => {
    if (attackers.length === 0) { setTimeout(() => { isOpponentTurnProcessing = false; endTurn(); }, 1000); return; }
    const attacker = attackers.shift();
    const attackerEl = document.querySelector(`#${attacker.zone} .card`);
    if (!attackerEl) { attackNext(); return; }
    let target = playerPlayedCards.find(p => p.card.def <= attacker.card.atk);
    let targetEl = null;
    if (target) { targetEl = document.querySelector(`#${target.zone} .card`); if (targetEl) targetEl.classList.add('ai-attack-target'); }
    attackerEl.classList.add('attacking'); playSound("attack-sound");
    setTimeout(() => {
      attackerEl.classList.remove('attacking'); attackerEl.classList.add('has-attacked'); attacker.card.hasAttacked = true;
      if (target && targetEl) {
        targetEl.classList.add('attacked');
        playerPlayedCards = playerPlayedCards.filter(p => p.card.id !== target.card.id);
        playerCrypt.push(target.card); updatePlayerCrypt();
        setTimeout(() => targetEl.remove(), 800);
      } else if (playerPlayedCards.length === 0) {
        playerLife -= attacker.card.atk; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`;
        showNotification(`Opponent attacks for ${attacker.card.atk}!`);
      }
      updatePlayerZone(); updateOpponentZone(); checkGameOver();
      setTimeout(attackNext, 1200);
    }, 900);
  };
  setTimeout(attackNext, 600);
}
function opponentPlayCard(card, idx) {
  opponentMana -= card.mana; updateManaDisplays();
  opponentHand.splice(idx, 1); document.querySelector(`.opponent-hand .card[data-id="${card.id}"]`)?.remove();
  if (card.type === "spell") {
    const zones = [];
    for (let i = 1; i <= 3; i++) if (!opponentSpellField.find(e => e.zone === `opponent-spell-zone-${i}`)) zones.push(i);
    if (zones.length > 0) {
      const z = zones[Math.floor(Math.random() * zones.length)];
      opponentSpellField.push({ card, zone: `opponent-spell-zone-${z}` });
      updateOpponentSpellZone();
      const el = document.querySelector(`#opponent-spell-zone-${z} .card`);
      if (el) { el.classList.add('spell-glow'); playSound('spell-sound'); }
      setTimeout(() => {
        opponentSpellField = opponentSpellField.filter(e => e.card.id !== card.id);
        opponentCrypt.push(card); updateOpponentCrypt(); updateOpponentSpellZone();
        if (card.effect.includes("damage")) { const dmg = card.effect.includes("3") ? 3 : 2; playerLife -= dmg; document.getElementById('player-life').innerText = `Player Life: ${playerLife}`; }
        else if (card.effect === "Restore 3 life") { opponentLife += 3; document.getElementById('opponent-life').innerText = `Opponent Life: ${opponentLife}`; }
        else if (card.effect === "Draw 2 cards") { for (let i = 0; i < 2 && opponentHand.length < maxHandSize; i++) drawCard(opponentDeck, opponentHand, ".opponent-hand"); }
        checkGameOver();
      }, 800);
    }
  } else {
    const zones = [];
    for (let i = 1; i <= 5; i++) if (!opponentPlayedCards.find(e => e.zone === `opponent-monster-zone-${i}`)) zones.push(i);
    if (zones.length > 0) {
      const z = zones[Math.floor(Math.random() * zones.length)];
      card.hasAttacked = false; opponentPlayedCards.push({ card, zone: `opponent-monster-zone-${z}` });
      updateOpponentZone();
      const el = document.querySelector(`#opponent-monster-zone-${z} .card`);
      if (el) { el.classList.add('summon-glow'); addParticles(el); playSound('play-sound'); setTimeout(() => el.classList.remove('summon-glow'), 1200); }
    }
  }
  checkGameOver();
}

// START
window.addEventListener('load', showDeckSelectionPopup);
</script>
</body>
</html>
